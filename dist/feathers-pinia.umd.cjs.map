{"version":3,"file":"feathers-pinia.umd.cjs","sources":["../node_modules/fast-deep-equal/index.js","../node_modules/fast-copy/dist/esm/index.mjs","../src/utils/define-properties.ts","../src/utils/convert-data.ts","../src/utils/utils.ts","../src/utils/use-counter.ts","../src/utils/deep-unref.ts","../src/utils/use-instance-defaults.ts","../src/utils/service-utils.ts","../src/utils/index.ts","../node_modules/@vueuse/shared/index.mjs","../node_modules/fast-json-stable-stringify/index.js","../src/use-find-get/utils.ts","../src/use-find-get/utils-pagination.ts","../src/use-find-get/use-find.ts","../src/use-find-get/use-get.ts","../src/create-pinia-service.ts","../node_modules/isomorphic-mongo-objectid/src/isomorphic-mongo-objectid.js","../node_modules/isomorphic-mongo-objectid/index.js","../src/modeling/use-model-instance.ts","../node_modules/sift/es5m/index.js","../src/stores/utils-custom-operators.ts","../src/stores/local-queries.ts","../src/stores/storage.ts","../src/stores/temps.ts","../src/stores/clones.ts","../src/stores/all-storage-types.ts","../src/stores/use-data-store.ts","../node_modules/@feathersjs/commons/lib/debug.js","../node_modules/@feathersjs/commons/lib/index.js","../src/stores/pagination.ts","../src/stores/pending.ts","../src/stores/event-locks.ts","../src/stores/ssr-query-cache.ts","../src/stores/use-service-store.ts","../src/stores/event-queue-promise.ts","../node_modules/just-debounce/index.js","../src/stores/events.ts","../src/hooks/0-prepare-query.ts","../src/hooks/1-set-pending.ts","../src/hooks/2-event-locks.ts","../src/hooks/3-sync-store.ts","../src/hooks/4-model-instances.ts","../src/hooks/5-handle-find-ssr.ts","../src/hooks/6-normalize-find.ts","../src/hooks/7-skip-get-if-exists.ts","../src/hooks/8-patch-diffs.ts","../src/hooks/9-ssr-qid-cache.ts","../src/hooks/index.ts","../src/modeling/use-feathers-instance.ts","../src/modeling/store-associated.ts","../src/localstorage/storage-sync.ts","../src/localstorage/clear-storage.ts","../src/create-pinia-client.ts","../src/feathers-ofetch.ts","../src/unplugin-auto-import-preset.ts","../node_modules/jwt-decode/build/esm/index.js","../src/use-auth/use-auth.ts","../src/composables/use-backup.ts"],"sourcesContent":["'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","var toStringFunction = Function.prototype.toString;\nvar create = Object.create;\nvar toStringObject = Object.prototype.toString;\n/**\n * @classdesc Fallback cache for when WeakMap is not natively supported\n */\nvar LegacyCache = /** @class */ (function () {\n    function LegacyCache() {\n        this._keys = [];\n        this._values = [];\n    }\n    LegacyCache.prototype.has = function (key) {\n        return !!~this._keys.indexOf(key);\n    };\n    LegacyCache.prototype.get = function (key) {\n        return this._values[this._keys.indexOf(key)];\n    };\n    LegacyCache.prototype.set = function (key, value) {\n        this._keys.push(key);\n        this._values.push(value);\n    };\n    return LegacyCache;\n}());\nfunction createCacheLegacy() {\n    return new LegacyCache();\n}\nfunction createCacheModern() {\n    return new WeakMap();\n}\n/**\n * Get a new cache object to prevent circular references.\n */\nvar createCache = typeof WeakMap !== 'undefined' ? createCacheModern : createCacheLegacy;\n/**\n * Get an empty version of the object with the same prototype it has.\n */\nfunction getCleanClone(prototype) {\n    if (!prototype) {\n        return create(null);\n    }\n    var Constructor = prototype.constructor;\n    if (Constructor === Object) {\n        return prototype === Object.prototype ? {} : create(prototype);\n    }\n    if (~toStringFunction.call(Constructor).indexOf('[native code]')) {\n        try {\n            return new Constructor();\n        }\n        catch (_a) { }\n    }\n    return create(prototype);\n}\nfunction getRegExpFlagsLegacy(regExp) {\n    var flags = '';\n    if (regExp.global) {\n        flags += 'g';\n    }\n    if (regExp.ignoreCase) {\n        flags += 'i';\n    }\n    if (regExp.multiline) {\n        flags += 'm';\n    }\n    if (regExp.unicode) {\n        flags += 'u';\n    }\n    if (regExp.sticky) {\n        flags += 'y';\n    }\n    return flags;\n}\nfunction getRegExpFlagsModern(regExp) {\n    return regExp.flags;\n}\n/**\n * Get the flags to apply to the copied regexp.\n */\nvar getRegExpFlags = /test/g.flags === 'g' ? getRegExpFlagsModern : getRegExpFlagsLegacy;\nfunction getTagLegacy(value) {\n    var type = toStringObject.call(value);\n    return type.substring(8, type.length - 1);\n}\nfunction getTagModern(value) {\n    return value[Symbol.toStringTag] || getTagLegacy(value);\n}\n/**\n * Get the tag of the value passed, so that the correct copier can be used.\n */\nvar getTag = typeof Symbol !== 'undefined' ? getTagModern : getTagLegacy;\n\nvar defineProperty = Object.defineProperty, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar _a = Object.prototype, hasOwnProperty = _a.hasOwnProperty, propertyIsEnumerable = _a.propertyIsEnumerable;\nvar SUPPORTS_SYMBOL = typeof getOwnPropertySymbols === 'function';\nfunction getStrictPropertiesModern(object) {\n    return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));\n}\n/**\n * Get the properites used when copying objects strictly. This includes both keys and symbols.\n */\nvar getStrictProperties = SUPPORTS_SYMBOL\n    ? getStrictPropertiesModern\n    : getOwnPropertyNames;\n/**\n * Striclty copy all properties contained on the object.\n */\nfunction copyOwnPropertiesStrict(value, clone, state) {\n    var properties = getStrictProperties(value);\n    for (var index = 0, length_1 = properties.length, property = void 0, descriptor = void 0; index < length_1; ++index) {\n        property = properties[index];\n        if (property === 'callee' || property === 'caller') {\n            continue;\n        }\n        descriptor = getOwnPropertyDescriptor(value, property);\n        if (!descriptor) {\n            // In extra edge cases where the property descriptor cannot be retrived, fall back to\n            // the loose assignment.\n            clone[property] = state.copier(value[property], state);\n            continue;\n        }\n        // Only clone the value if actually a value, not a getter / setter.\n        if (!descriptor.get && !descriptor.set) {\n            descriptor.value = state.copier(descriptor.value, state);\n        }\n        try {\n            defineProperty(clone, property, descriptor);\n        }\n        catch (error) {\n            // Tee above can fail on node in edge cases, so fall back to the loose assignment.\n            clone[property] = descriptor.value;\n        }\n    }\n    return clone;\n}\n/**\n * Deeply copy the indexed values in the array.\n */\nfunction copyArrayLoose(array, state) {\n    var clone = new state.Constructor();\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(array, clone);\n    for (var index = 0, length_2 = array.length; index < length_2; ++index) {\n        clone[index] = state.copier(array[index], state);\n    }\n    return clone;\n}\n/**\n * Deeply copy the indexed values in the array, as well as any custom properties.\n */\nfunction copyArrayStrict(array, state) {\n    var clone = new state.Constructor();\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(array, clone);\n    return copyOwnPropertiesStrict(array, clone, state);\n}\n/**\n * Copy the contents of the ArrayBuffer.\n */\nfunction copyArrayBuffer(arrayBuffer, _state) {\n    return arrayBuffer.slice(0);\n}\n/**\n * Create a new Blob with the contents of the original.\n */\nfunction copyBlob(blob, _state) {\n    return blob.slice(0, blob.size, blob.type);\n}\n/**\n * Create a new DataView with the contents of the original.\n */\nfunction copyDataView(dataView, state) {\n    return new state.Constructor(copyArrayBuffer(dataView.buffer));\n}\n/**\n * Create a new Date based on the time of the original.\n */\nfunction copyDate(date, state) {\n    return new state.Constructor(date.getTime());\n}\n/**\n * Deeply copy the keys and values of the original.\n */\nfunction copyMapLoose(map, state) {\n    var clone = new state.Constructor();\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(map, clone);\n    map.forEach(function (value, key) {\n        clone.set(key, state.copier(value, state));\n    });\n    return clone;\n}\n/**\n * Deeply copy the keys and values of the original, as well as any custom properties.\n */\nfunction copyMapStrict(map, state) {\n    return copyOwnPropertiesStrict(map, copyMapLoose(map, state), state);\n}\nfunction copyObjectLooseLegacy(object, state) {\n    var clone = getCleanClone(state.prototype);\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(object, clone);\n    for (var key in object) {\n        if (hasOwnProperty.call(object, key)) {\n            clone[key] = state.copier(object[key], state);\n        }\n    }\n    return clone;\n}\nfunction copyObjectLooseModern(object, state) {\n    var clone = getCleanClone(state.prototype);\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(object, clone);\n    for (var key in object) {\n        if (hasOwnProperty.call(object, key)) {\n            clone[key] = state.copier(object[key], state);\n        }\n    }\n    var symbols = getOwnPropertySymbols(object);\n    for (var index = 0, length_3 = symbols.length, symbol = void 0; index < length_3; ++index) {\n        symbol = symbols[index];\n        if (propertyIsEnumerable.call(object, symbol)) {\n            clone[symbol] = state.copier(object[symbol], state);\n        }\n    }\n    return clone;\n}\n/**\n * Deeply copy the properties (keys and symbols) and values of the original.\n */\nvar copyObjectLoose = SUPPORTS_SYMBOL\n    ? copyObjectLooseModern\n    : copyObjectLooseLegacy;\n/**\n * Deeply copy the properties (keys and symbols) and values of the original, as well\n * as any hidden or non-enumerable properties.\n */\nfunction copyObjectStrict(object, state) {\n    var clone = getCleanClone(state.prototype);\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(object, clone);\n    return copyOwnPropertiesStrict(object, clone, state);\n}\n/**\n * Create a new primitive wrapper from the value of the original.\n */\nfunction copyPrimitiveWrapper(primitiveObject, state) {\n    return new state.Constructor(primitiveObject.valueOf());\n}\n/**\n * Create a new RegExp based on the value and flags of the original.\n */\nfunction copyRegExp(regExp, state) {\n    var clone = new state.Constructor(regExp.source, getRegExpFlags(regExp));\n    clone.lastIndex = regExp.lastIndex;\n    return clone;\n}\n/**\n * Return the original value (an identity function).\n *\n * @note\n * THis is used for objects that cannot be copied, such as WeakMap.\n */\nfunction copySelf(value, _state) {\n    return value;\n}\n/**\n * Deeply copy the values of the original.\n */\nfunction copySetLoose(set, state) {\n    var clone = new state.Constructor();\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(set, clone);\n    set.forEach(function (value) {\n        clone.add(state.copier(value, state));\n    });\n    return clone;\n}\n/**\n * Deeply copy the values of the original, as well as any custom properties.\n */\nfunction copySetStrict(set, state) {\n    return copyOwnPropertiesStrict(set, copySetLoose(set, state), state);\n}\n\nvar isArray = Array.isArray;\nvar assign = Object.assign;\nvar getPrototypeOf = Object.getPrototypeOf || (function (obj) { return obj.__proto__; });\nvar DEFAULT_LOOSE_OPTIONS = {\n    array: copyArrayLoose,\n    arrayBuffer: copyArrayBuffer,\n    blob: copyBlob,\n    dataView: copyDataView,\n    date: copyDate,\n    error: copySelf,\n    map: copyMapLoose,\n    object: copyObjectLoose,\n    regExp: copyRegExp,\n    set: copySetLoose,\n};\nvar DEFAULT_STRICT_OPTIONS = assign({}, DEFAULT_LOOSE_OPTIONS, {\n    array: copyArrayStrict,\n    map: copyMapStrict,\n    object: copyObjectStrict,\n    set: copySetStrict,\n});\n/**\n * Get the copiers used for each specific object tag.\n */\nfunction getTagSpecificCopiers(options) {\n    return {\n        Arguments: options.object,\n        Array: options.array,\n        ArrayBuffer: options.arrayBuffer,\n        Blob: options.blob,\n        Boolean: copyPrimitiveWrapper,\n        DataView: options.dataView,\n        Date: options.date,\n        Error: options.error,\n        Float32Array: options.arrayBuffer,\n        Float64Array: options.arrayBuffer,\n        Int8Array: options.arrayBuffer,\n        Int16Array: options.arrayBuffer,\n        Int32Array: options.arrayBuffer,\n        Map: options.map,\n        Number: copyPrimitiveWrapper,\n        Object: options.object,\n        Promise: copySelf,\n        RegExp: options.regExp,\n        Set: options.set,\n        String: copyPrimitiveWrapper,\n        WeakMap: copySelf,\n        WeakSet: copySelf,\n        Uint8Array: options.arrayBuffer,\n        Uint8ClampedArray: options.arrayBuffer,\n        Uint16Array: options.arrayBuffer,\n        Uint32Array: options.arrayBuffer,\n        Uint64Array: options.arrayBuffer,\n    };\n}\n/**\n * Create a custom copier based on the object-specific copy methods passed.\n */\nfunction createCopier(options) {\n    var normalizedOptions = assign({}, DEFAULT_LOOSE_OPTIONS, options);\n    var tagSpecificCopiers = getTagSpecificCopiers(normalizedOptions);\n    var array = tagSpecificCopiers.Array, object = tagSpecificCopiers.Object;\n    function copier(value, state) {\n        state.prototype = state.Constructor = undefined;\n        if (!value || typeof value !== 'object') {\n            return value;\n        }\n        if (state.cache.has(value)) {\n            return state.cache.get(value);\n        }\n        state.prototype = getPrototypeOf(value);\n        state.Constructor = state.prototype && state.prototype.constructor;\n        // plain objects\n        if (!state.Constructor || state.Constructor === Object) {\n            return object(value, state);\n        }\n        // arrays\n        if (isArray(value)) {\n            return array(value, state);\n        }\n        var tagSpecificCopier = tagSpecificCopiers[getTag(value)];\n        if (tagSpecificCopier) {\n            return tagSpecificCopier(value, state);\n        }\n        return typeof value.then === 'function' ? value : object(value, state);\n    }\n    return function copy(value) {\n        return copier(value, {\n            Constructor: undefined,\n            cache: createCache(),\n            copier: copier,\n            prototype: undefined,\n        });\n    };\n}\n/**\n * Create a custom copier based on the object-specific copy methods passed, defaulting to the\n * same internals as `copyStrict`.\n */\nfunction createStrictCopier(options) {\n    return createCopier(assign({}, DEFAULT_STRICT_OPTIONS, options));\n}\n/**\n * Copy an value deeply as much as possible, where strict recreation of object properties\n * are maintained. All properties (including non-enumerable ones) are copied with their\n * original property descriptors on both objects and arrays.\n */\nvar copyStrict = createStrictCopier({});\n/**\n * Copy an value deeply as much as possible.\n */\nvar index = createCopier({});\n\nexport { copyStrict, createCopier, createStrictCopier, index as default };\n//# sourceMappingURL=index.mjs.map\n","import type { AnyData } from '../types.js'\n\n/**\n * Defines all provided properties as non-enumerable, configurable, values\n */\nexport function defineValues<M extends AnyData, D extends AnyData>(data: M, properties: D) {\n  Object.keys(properties).forEach((key) => {\n    Object.defineProperty(data, key, {\n      enumerable: false,\n      configurable: true,\n      value: properties[key],\n    })\n  })\n  return data\n}\n\n/**\n * Defines all provided properties as non-enumerable, configurable, getters\n */\nexport function defineGetters<M extends AnyData, D extends AnyData>(data: M, properties: D) {\n  Object.keys(properties).forEach((key) => {\n    Object.defineProperty(data, key, {\n      enumerable: false,\n      configurable: true,\n      get: properties[key],\n    })\n  })\n  return data\n}\n\n/**\n * Defines all provided properties as non-enumerable, configurable, setters\n */\nexport function defineSetters<M extends AnyData, D extends AnyData>(data: M, properties: D) {\n  Object.keys(properties).forEach((key) => {\n    // eslint-disable-next-line accessor-pairs\n    Object.defineProperty(data, key, {\n      enumerable: false,\n      configurable: true,\n      set: properties[key],\n    })\n  })\n  return data\n}\n","import type { FeathersService } from '@feathersjs/feathers'\nimport type { PiniaService } from '../create-pinia-service.js'\nimport type { AnyData, AnyDataOrArray } from '../types.js'\nimport type { ServiceInstance } from '../modeling/index.js'\n\nexport function convertData(service: PiniaService<FeathersService>, result: AnyDataOrArray<AnyData>) {\n  if (!result) {\n    return result\n  }\n  else if (Array.isArray(result)) {\n    return result.map(i => service.new(i)) as ServiceInstance<AnyData>[]\n  }\n  else if (result && Array.isArray(result.data)) {\n    result.data = result.data.map(i => service.new(i)) as ServiceInstance<AnyData>[]\n    return result\n  }\n  else {\n    return service.new(result) as ServiceInstance<AnyData>\n  }\n}\n","import type { MaybeRef } from '@vueuse/core'\nimport type { Ref } from 'vue-demi'\nimport { _ } from '@feathersjs/commons'\nimport { unref } from 'vue-demi'\nimport isEqual from 'fast-deep-equal'\nimport fastCopy from 'fast-copy'\nimport type { AnyData, AnyDataOrArray, DiffDefinition, Params, Query, QueryInfo } from '../types.js'\nimport { defineValues } from './define-properties.js'\nimport { convertData } from './convert-data.js'\n\ninterface GetExtendedQueryInfoOptions {\n  queryInfo: QueryInfo\n  service: any\n  store: any\n  qid: Ref<string>\n}\nexport function getExtendedQueryInfo({ queryInfo, service, store, qid }: GetExtendedQueryInfoOptions) {\n  const qidState: any = store.pagination[qid.value]\n  const queryState = qidState[queryInfo.queryId]\n  if (!queryState)\n    return null\n\n  const { total } = queryState\n  const pageState = queryState[queryInfo.pageId as string]\n  if (!pageState)\n    return null\n\n  const { ids, queriedAt, ssr } = pageState\n  const result = ids.map((id: any) => store.itemsById[id]).filter((i: any) => i)\n  const items = convertData(service, result)\n  const info = { ...queryInfo, ids, items, total, queriedAt, queryState, ssr }\n  return info || null\n}\n\nexport function hasOwn(obj: AnyData, prop: string) {\n  return Object.prototype.hasOwnProperty.call(obj, prop)\n}\n\n/**\n *\n * @param data item or array of items\n * @returns object with { items[], isArray } where isArray is a boolean of if the data was an array.\n */\nexport function getArray<T>(data: T | T[]) {\n  const isArray = Array.isArray(data)\n  return { items: isArray ? data : [data], isArray }\n}\n\nexport function pickDiff(obj: any, diffDef: DiffDefinition) {\n  // If no diff definition was given, return the entire object.\n  if (!diffDef)\n    return obj\n\n  // Normalize all types into an array and pick the keys\n  const keys = typeof diffDef === 'string' ? [diffDef] : Array.isArray(diffDef) ? diffDef : Object.keys(diffDef || obj)\n  const topLevelKeys = keys.map(key => key.toString().split('.')[0])\n  return _.pick(obj, ...topLevelKeys)\n}\n\nexport function diff(dest: AnyData, source: AnyData, diffDef?: DiffDefinition) {\n  const originalVal = pickDiff(dest, diffDef)\n  const cloneVal = pickDiff(source, diffDef)\n\n  // If diff was an object, merge the values into the cloneVal\n  if (typeof diffDef !== 'string' && !Array.isArray(diffDef))\n    Object.assign(cloneVal, diffDef)\n\n  const areEqual = isEqual(originalVal, cloneVal)\n\n  if (areEqual)\n    return {}\n\n  // Loop through clone, compare original value to clone value, if different add to diff object.\n  const diff = Object.keys(cloneVal).reduce((diff: AnyData, key) => {\n    if (!isEqual(dest[key], cloneVal[key]))\n      diff[key] = cloneVal[key]\n\n    return diff\n  }, {})\n\n  return diff\n}\n\n/**\n * Restores tempIds to the records returned from the server. The tempIds need to be\n * temporarily put back in place in order to migrate the objects from the tempsById\n * into the itemsById. A shallow copy of the object\n *\n * Note when data is an array, it doesn't matter if the server\n * returns the items in the same order. It's only important that all of the correct\n * records are moved from tempsById to itemsById\n *\n * @param data item(s) before being passed to the server\n * @param responseData items(s) returned from the server\n */\nexport function restoreTempIds(data: AnyDataOrArray<any>, resData: AnyDataOrArray<any>, tempIdField = '__tempId') {\n  const { items: sourceItems, isArray } = getArray(data)\n  const { items: responseItems } = getArray(resData)\n\n  responseItems.forEach((item: any, index: number) => {\n    const tempId = sourceItems[index][tempIdField]\n    if (tempId)\n      defineValues(item, { [tempIdField]: tempId })\n  })\n\n  return isArray ? responseItems : responseItems[0]\n}\n\nfunction stringifyIfObject(val: any): string | any {\n  if (typeof val === 'object' && val != null)\n    return val.toString()\n\n  return val\n}\n\n/**\n * Get the id from a record in this order:\n *   1. the `idField`\n *   2. id\n *   3. _id\n * @param item\n * @param idField\n */\nexport function getId(item: any, idField: string) {\n  if (!item)\n    return\n  if (idField && item[idField] !== undefined)\n    return stringifyIfObject(item[idField as string])\n\n  if (item.id !== undefined)\n    return stringifyIfObject(item.id)\n\n  if (item._id !== undefined)\n    return stringifyIfObject(item._id)\n}\n\n/**\n * Assures params exist.\n * @param params existing params\n */\nexport function getParams(params?: MaybeRef<Params<Query>>): Params<Query> {\n  if (!params)\n    return {}\n\n  return fastCopy(unref(params))\n}\n\nexport function timeout(ms: number) {\n  return new Promise(resolve => setTimeout(resolve, ms))\n}\n","import { ref } from 'vue-demi'\n\n/**\n * Use a counter to track the number of pending queries. Prevents collisions with overlapping queries.\n */\nexport function useCounter() {\n  const count = ref(0)\n  const add = () => {\n    count.value = count.value + 1\n  }\n  const sub = () => {\n    count.value = count.value === 0 ? 0 : count.value - 1\n  }\n  return { count, add, sub }\n}\n","import type { MaybeRef } from '@vueuse/core'\nimport { isRef, unref } from 'vue-demi'\n\nconst isObject = (val: Record<string, any>) => val !== null && typeof val === 'object'\nconst isArray = Array.isArray\n\n// Unref a value, recursing into it if it's an object.\nfunction smartUnref(val: Record<string, any>) {\n  // Non-ref object?  Go deeper!\n  if (val !== null && !isRef(val) && typeof val === 'object')\n    return deepUnref(val)\n\n  return unref(val)\n}\n\n// Unref an array, recursively.\nconst unrefArray = (arr: any) => arr.map(smartUnref)\n\n// Unref an object, recursively.\nfunction unrefObject(obj: Record<string, any>) {\n  const unreffed: Record<string, any> = {}\n\n  Object.keys(obj).forEach((key) => {\n    unreffed[key] = smartUnref(obj[key])\n  })\n\n  return unreffed\n}\n\n/**\n * Deeply unref a value, recursing into objects and arrays.\n *\n * Adapted from https://github.com/DanHulton/vue-deepunref\n */\nexport function deepUnref(val: MaybeRef<Record<string, any>>) {\n  const checkedVal: any = isRef(val) ? unref(val) : val\n\n  if (!isObject(checkedVal))\n    return checkedVal\n\n  if (isArray(checkedVal))\n    return unrefArray(checkedVal)\n\n  return unrefObject(checkedVal)\n}\n","import fastCopy from 'fast-copy'\nimport { _ } from '@feathersjs/commons'\nimport type { AnyData } from '../types.js'\n\nexport function useInstanceDefaults<D extends AnyData, M extends AnyData>(defaults: D, data: M) {\n  const dataKeys = Object.keys(data)\n  const defaultsToApply = _.omit(defaults, ...dataKeys) as D\n  const cloned = Object.assign(data, fastCopy(defaultsToApply))\n\n  return cloned\n}\n","/**\n * Push data to the store and return the new data.\n */\nexport function pushToStore<Data>(data: Data, service: { createInStore: any }) {\n  if (!data)\n    return data\n\n  const createInStore = (item: any) => service.createInStore(item)\n\n  if (Array.isArray(data))\n    return data.map(createInStore)\n\n  else\n    return createInStore(data)\n}\n\n/**\n * Define a virtual property on an object.\n */\nexport function defineVirtualProperty<Data>(data: Data, key: string, getter: any) {\n  const definition: any = { enumerable: false }\n  if (typeof getter === 'function') {\n    definition.get = function get(this: Data) {\n      return getter(this as Data)\n    }\n  }\n  else { definition.value = getter }\n\n  Object.defineProperty(data, key, definition)\n}\n\nexport function defineVirtualProperties<Data>(data: Data, getters: Record<string, any>) {\n  Object.keys(getters).forEach(key => defineVirtualProperty(data, key, getters[key]))\n}\n","export * from './utils'\nexport * from './use-counter'\nexport * from './convert-data'\nexport * from './define-properties'\nexport * from './deep-unref'\nexport * from './use-instance-defaults'\nexport * from './service-utils'\n\n// typical Feathers service methods not on PiniaService\nexport const existingServiceMethods = [\n  'update',\n  'hooks',\n  'setMaxListeners',\n  'getMaxListeners',\n  'addListener',\n  'prependListener',\n  'once',\n  'prependOnceListener',\n  'removeListener',\n  'off',\n  'removeAllListeners',\n  'listeners',\n  'rawListeners',\n  'emit',\n  'eventNames',\n  'listenerCount',\n  'on',\n]\n","import { shallowRef, watchEffect, readonly, ref, watch, customRef, getCurrentScope, onScopeDispose, effectScope, getCurrentInstance, provide, inject, isVue3, version, isRef, unref, computed, reactive, toRefs as toRefs$1, toRef as toRef$1, isVue2, set as set$1, onBeforeMount, nextTick, onBeforeUnmount, onMounted, onUnmounted, isReactive } from 'vue-demi';\n\nfunction computedEager(fn, options) {\n  var _a;\n  const result = shallowRef();\n  watchEffect(() => {\n    result.value = fn();\n  }, {\n    ...options,\n    flush: (_a = options == null ? void 0 : options.flush) != null ? _a : \"sync\"\n  });\n  return readonly(result);\n}\n\nfunction computedWithControl(source, fn) {\n  let v = void 0;\n  let track;\n  let trigger;\n  const dirty = ref(true);\n  const update = () => {\n    dirty.value = true;\n    trigger();\n  };\n  watch(source, update, { flush: \"sync\" });\n  const get = typeof fn === \"function\" ? fn : fn.get;\n  const set = typeof fn === \"function\" ? void 0 : fn.set;\n  const result = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        if (dirty.value) {\n          v = get();\n          dirty.value = false;\n        }\n        track();\n        return v;\n      },\n      set(v2) {\n        set == null ? void 0 : set(v2);\n      }\n    };\n  });\n  if (Object.isExtensible(result))\n    result.trigger = update;\n  return result;\n}\n\nfunction tryOnScopeDispose(fn) {\n  if (getCurrentScope()) {\n    onScopeDispose(fn);\n    return true;\n  }\n  return false;\n}\n\nfunction createEventHook() {\n  const fns = /* @__PURE__ */ new Set();\n  const off = (fn) => {\n    fns.delete(fn);\n  };\n  const on = (fn) => {\n    fns.add(fn);\n    const offFn = () => off(fn);\n    tryOnScopeDispose(offFn);\n    return {\n      off: offFn\n    };\n  };\n  const trigger = (...args) => {\n    return Promise.all(Array.from(fns).map((fn) => fn(...args)));\n  };\n  return {\n    on,\n    off,\n    trigger\n  };\n}\n\nfunction createGlobalState(stateFactory) {\n  let initialized = false;\n  let state;\n  const scope = effectScope(true);\n  return (...args) => {\n    if (!initialized) {\n      state = scope.run(() => stateFactory(...args));\n      initialized = true;\n    }\n    return state;\n  };\n}\n\nconst localProvidedStateMap = /* @__PURE__ */ new WeakMap();\n\nconst provideLocal = (key, value) => {\n  var _a;\n  const instance = (_a = getCurrentInstance()) == null ? void 0 : _a.proxy;\n  if (instance == null)\n    throw new Error(\"provideLocal must be called in setup\");\n  if (!localProvidedStateMap.has(instance))\n    localProvidedStateMap.set(instance, /* @__PURE__ */ Object.create(null));\n  const localProvidedState = localProvidedStateMap.get(instance);\n  localProvidedState[key] = value;\n  provide(key, value);\n};\n\nconst injectLocal = (...args) => {\n  var _a;\n  const key = args[0];\n  const instance = (_a = getCurrentInstance()) == null ? void 0 : _a.proxy;\n  if (instance == null)\n    throw new Error(\"injectLocal must be called in setup\");\n  if (localProvidedStateMap.has(instance) && key in localProvidedStateMap.get(instance))\n    return localProvidedStateMap.get(instance)[key];\n  return inject(...args);\n};\n\nfunction createInjectionState(composable, options) {\n  const key = (options == null ? void 0 : options.injectionKey) || Symbol(composable.name || \"InjectionState\");\n  const useProvidingState = (...args) => {\n    const state = composable(...args);\n    provideLocal(key, state);\n    return state;\n  };\n  const useInjectedState = () => injectLocal(key);\n  return [useProvidingState, useInjectedState];\n}\n\nfunction createSharedComposable(composable) {\n  let subscribers = 0;\n  let state;\n  let scope;\n  const dispose = () => {\n    subscribers -= 1;\n    if (scope && subscribers <= 0) {\n      scope.stop();\n      state = void 0;\n      scope = void 0;\n    }\n  };\n  return (...args) => {\n    subscribers += 1;\n    if (!state) {\n      scope = effectScope(true);\n      state = scope.run(() => composable(...args));\n    }\n    tryOnScopeDispose(dispose);\n    return state;\n  };\n}\n\nfunction extendRef(ref, extend, { enumerable = false, unwrap = true } = {}) {\n  if (!isVue3 && !version.startsWith(\"2.7.\")) {\n    if (process.env.NODE_ENV !== \"production\")\n      throw new Error(\"[VueUse] extendRef only works in Vue 2.7 or above.\");\n    return;\n  }\n  for (const [key, value] of Object.entries(extend)) {\n    if (key === \"value\")\n      continue;\n    if (isRef(value) && unwrap) {\n      Object.defineProperty(ref, key, {\n        get() {\n          return value.value;\n        },\n        set(v) {\n          value.value = v;\n        },\n        enumerable\n      });\n    } else {\n      Object.defineProperty(ref, key, { value, enumerable });\n    }\n  }\n  return ref;\n}\n\nfunction get(obj, key) {\n  if (key == null)\n    return unref(obj);\n  return unref(obj)[key];\n}\n\nfunction isDefined(v) {\n  return unref(v) != null;\n}\n\nfunction makeDestructurable(obj, arr) {\n  if (typeof Symbol !== \"undefined\") {\n    const clone = { ...obj };\n    Object.defineProperty(clone, Symbol.iterator, {\n      enumerable: false,\n      value() {\n        let index = 0;\n        return {\n          next: () => ({\n            value: arr[index++],\n            done: index > arr.length\n          })\n        };\n      }\n    });\n    return clone;\n  } else {\n    return Object.assign([...arr], obj);\n  }\n}\n\nfunction toValue(r) {\n  return typeof r === \"function\" ? r() : unref(r);\n}\nconst resolveUnref = toValue;\n\nfunction reactify(fn, options) {\n  const unrefFn = (options == null ? void 0 : options.computedGetter) === false ? unref : toValue;\n  return function(...args) {\n    return computed(() => fn.apply(this, args.map((i) => unrefFn(i))));\n  };\n}\n\nfunction reactifyObject(obj, optionsOrKeys = {}) {\n  let keys = [];\n  let options;\n  if (Array.isArray(optionsOrKeys)) {\n    keys = optionsOrKeys;\n  } else {\n    options = optionsOrKeys;\n    const { includeOwnProperties = true } = optionsOrKeys;\n    keys.push(...Object.keys(obj));\n    if (includeOwnProperties)\n      keys.push(...Object.getOwnPropertyNames(obj));\n  }\n  return Object.fromEntries(\n    keys.map((key) => {\n      const value = obj[key];\n      return [\n        key,\n        typeof value === \"function\" ? reactify(value.bind(obj), options) : value\n      ];\n    })\n  );\n}\n\nfunction toReactive(objectRef) {\n  if (!isRef(objectRef))\n    return reactive(objectRef);\n  const proxy = new Proxy({}, {\n    get(_, p, receiver) {\n      return unref(Reflect.get(objectRef.value, p, receiver));\n    },\n    set(_, p, value) {\n      if (isRef(objectRef.value[p]) && !isRef(value))\n        objectRef.value[p].value = value;\n      else\n        objectRef.value[p] = value;\n      return true;\n    },\n    deleteProperty(_, p) {\n      return Reflect.deleteProperty(objectRef.value, p);\n    },\n    has(_, p) {\n      return Reflect.has(objectRef.value, p);\n    },\n    ownKeys() {\n      return Object.keys(objectRef.value);\n    },\n    getOwnPropertyDescriptor() {\n      return {\n        enumerable: true,\n        configurable: true\n      };\n    }\n  });\n  return reactive(proxy);\n}\n\nfunction reactiveComputed(fn) {\n  return toReactive(computed(fn));\n}\n\nfunction reactiveOmit(obj, ...keys) {\n  const flatKeys = keys.flat();\n  const predicate = flatKeys[0];\n  return reactiveComputed(() => typeof predicate === \"function\" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v]) => !predicate(toValue(v), k))) : Object.fromEntries(Object.entries(toRefs$1(obj)).filter((e) => !flatKeys.includes(e[0]))));\n}\n\nconst isClient = typeof window !== \"undefined\" && typeof document !== \"undefined\";\nconst isWorker = typeof WorkerGlobalScope !== \"undefined\" && globalThis instanceof WorkerGlobalScope;\nconst isDef = (val) => typeof val !== \"undefined\";\nconst notNullish = (val) => val != null;\nconst assert = (condition, ...infos) => {\n  if (!condition)\n    console.warn(...infos);\n};\nconst toString = Object.prototype.toString;\nconst isObject = (val) => toString.call(val) === \"[object Object]\";\nconst now = () => Date.now();\nconst timestamp = () => +Date.now();\nconst clamp = (n, min, max) => Math.min(max, Math.max(min, n));\nconst noop = () => {\n};\nconst rand = (min, max) => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\nconst hasOwn = (val, key) => Object.prototype.hasOwnProperty.call(val, key);\nconst isIOS = /* @__PURE__ */ getIsIOS();\nfunction getIsIOS() {\n  var _a, _b;\n  return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));\n}\n\nfunction createFilterWrapper(filter, fn) {\n  function wrapper(...args) {\n    return new Promise((resolve, reject) => {\n      Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);\n    });\n  }\n  return wrapper;\n}\nconst bypassFilter = (invoke) => {\n  return invoke();\n};\nfunction debounceFilter(ms, options = {}) {\n  let timer;\n  let maxTimer;\n  let lastRejector = noop;\n  const _clearTimeout = (timer2) => {\n    clearTimeout(timer2);\n    lastRejector();\n    lastRejector = noop;\n  };\n  const filter = (invoke) => {\n    const duration = toValue(ms);\n    const maxDuration = toValue(options.maxWait);\n    if (timer)\n      _clearTimeout(timer);\n    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {\n      if (maxTimer) {\n        _clearTimeout(maxTimer);\n        maxTimer = null;\n      }\n      return Promise.resolve(invoke());\n    }\n    return new Promise((resolve, reject) => {\n      lastRejector = options.rejectOnCancel ? reject : resolve;\n      if (maxDuration && !maxTimer) {\n        maxTimer = setTimeout(() => {\n          if (timer)\n            _clearTimeout(timer);\n          maxTimer = null;\n          resolve(invoke());\n        }, maxDuration);\n      }\n      timer = setTimeout(() => {\n        if (maxTimer)\n          _clearTimeout(maxTimer);\n        maxTimer = null;\n        resolve(invoke());\n      }, duration);\n    });\n  };\n  return filter;\n}\nfunction throttleFilter(...args) {\n  let lastExec = 0;\n  let timer;\n  let isLeading = true;\n  let lastRejector = noop;\n  let lastValue;\n  let ms;\n  let trailing;\n  let leading;\n  let rejectOnCancel;\n  if (!isRef(args[0]) && typeof args[0] === \"object\")\n    ({ delay: ms, trailing = true, leading = true, rejectOnCancel = false } = args[0]);\n  else\n    [ms, trailing = true, leading = true, rejectOnCancel = false] = args;\n  const clear = () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n      lastRejector();\n      lastRejector = noop;\n    }\n  };\n  const filter = (_invoke) => {\n    const duration = toValue(ms);\n    const elapsed = Date.now() - lastExec;\n    const invoke = () => {\n      return lastValue = _invoke();\n    };\n    clear();\n    if (duration <= 0) {\n      lastExec = Date.now();\n      return invoke();\n    }\n    if (elapsed > duration && (leading || !isLeading)) {\n      lastExec = Date.now();\n      invoke();\n    } else if (trailing) {\n      lastValue = new Promise((resolve, reject) => {\n        lastRejector = rejectOnCancel ? reject : resolve;\n        timer = setTimeout(() => {\n          lastExec = Date.now();\n          isLeading = true;\n          resolve(invoke());\n          clear();\n        }, Math.max(0, duration - elapsed));\n      });\n    }\n    if (!leading && !timer)\n      timer = setTimeout(() => isLeading = true, duration);\n    isLeading = false;\n    return lastValue;\n  };\n  return filter;\n}\nfunction pausableFilter(extendFilter = bypassFilter) {\n  const isActive = ref(true);\n  function pause() {\n    isActive.value = false;\n  }\n  function resume() {\n    isActive.value = true;\n  }\n  const eventFilter = (...args) => {\n    if (isActive.value)\n      extendFilter(...args);\n  };\n  return { isActive: readonly(isActive), pause, resume, eventFilter };\n}\n\nconst directiveHooks = {\n  mounted: isVue3 ? \"mounted\" : \"inserted\",\n  updated: isVue3 ? \"updated\" : \"componentUpdated\",\n  unmounted: isVue3 ? \"unmounted\" : \"unbind\"\n};\n\nfunction cacheStringFunction(fn) {\n  const cache = /* @__PURE__ */ Object.create(null);\n  return (str) => {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n}\nconst hyphenateRE = /\\B([A-Z])/g;\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, \"-$1\").toLowerCase());\nconst camelizeRE = /-(\\w)/g;\nconst camelize = cacheStringFunction((str) => {\n  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : \"\");\n});\n\nfunction promiseTimeout(ms, throwOnTimeout = false, reason = \"Timeout\") {\n  return new Promise((resolve, reject) => {\n    if (throwOnTimeout)\n      setTimeout(() => reject(reason), ms);\n    else\n      setTimeout(resolve, ms);\n  });\n}\nfunction identity(arg) {\n  return arg;\n}\nfunction createSingletonPromise(fn) {\n  let _promise;\n  function wrapper() {\n    if (!_promise)\n      _promise = fn();\n    return _promise;\n  }\n  wrapper.reset = async () => {\n    const _prev = _promise;\n    _promise = void 0;\n    if (_prev)\n      await _prev;\n  };\n  return wrapper;\n}\nfunction invoke(fn) {\n  return fn();\n}\nfunction containsProp(obj, ...props) {\n  return props.some((k) => k in obj);\n}\nfunction increaseWithUnit(target, delta) {\n  var _a;\n  if (typeof target === \"number\")\n    return target + delta;\n  const value = ((_a = target.match(/^-?[0-9]+\\.?[0-9]*/)) == null ? void 0 : _a[0]) || \"\";\n  const unit = target.slice(value.length);\n  const result = Number.parseFloat(value) + delta;\n  if (Number.isNaN(result))\n    return target;\n  return result + unit;\n}\nfunction objectPick(obj, keys, omitUndefined = false) {\n  return keys.reduce((n, k) => {\n    if (k in obj) {\n      if (!omitUndefined || obj[k] !== void 0)\n        n[k] = obj[k];\n    }\n    return n;\n  }, {});\n}\nfunction objectOmit(obj, keys, omitUndefined = false) {\n  return Object.fromEntries(Object.entries(obj).filter(([key, value]) => {\n    return (!omitUndefined || value !== void 0) && !keys.includes(key);\n  }));\n}\nfunction objectEntries(obj) {\n  return Object.entries(obj);\n}\nfunction getLifeCycleTarget(target) {\n  return target || getCurrentInstance();\n}\n\nfunction toRef(...args) {\n  if (args.length !== 1)\n    return toRef$1(...args);\n  const r = args[0];\n  return typeof r === \"function\" ? readonly(customRef(() => ({ get: r, set: noop }))) : ref(r);\n}\nconst resolveRef = toRef;\n\nfunction reactivePick(obj, ...keys) {\n  const flatKeys = keys.flat();\n  const predicate = flatKeys[0];\n  return reactiveComputed(() => typeof predicate === \"function\" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v]) => predicate(toValue(v), k))) : Object.fromEntries(flatKeys.map((k) => [k, toRef(obj, k)])));\n}\n\nfunction refAutoReset(defaultValue, afterMs = 1e4) {\n  return customRef((track, trigger) => {\n    let value = toValue(defaultValue);\n    let timer;\n    const resetAfter = () => setTimeout(() => {\n      value = toValue(defaultValue);\n      trigger();\n    }, toValue(afterMs));\n    tryOnScopeDispose(() => {\n      clearTimeout(timer);\n    });\n    return {\n      get() {\n        track();\n        return value;\n      },\n      set(newValue) {\n        value = newValue;\n        trigger();\n        clearTimeout(timer);\n        timer = resetAfter();\n      }\n    };\n  });\n}\n\nfunction useDebounceFn(fn, ms = 200, options = {}) {\n  return createFilterWrapper(\n    debounceFilter(ms, options),\n    fn\n  );\n}\n\nfunction refDebounced(value, ms = 200, options = {}) {\n  const debounced = ref(value.value);\n  const updater = useDebounceFn(() => {\n    debounced.value = value.value;\n  }, ms, options);\n  watch(value, () => updater());\n  return debounced;\n}\n\nfunction refDefault(source, defaultValue) {\n  return computed({\n    get() {\n      var _a;\n      return (_a = source.value) != null ? _a : defaultValue;\n    },\n    set(value) {\n      source.value = value;\n    }\n  });\n}\n\nfunction useThrottleFn(fn, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {\n  return createFilterWrapper(\n    throttleFilter(ms, trailing, leading, rejectOnCancel),\n    fn\n  );\n}\n\nfunction refThrottled(value, delay = 200, trailing = true, leading = true) {\n  if (delay <= 0)\n    return value;\n  const throttled = ref(value.value);\n  const updater = useThrottleFn(() => {\n    throttled.value = value.value;\n  }, delay, trailing, leading);\n  watch(value, () => updater());\n  return throttled;\n}\n\nfunction refWithControl(initial, options = {}) {\n  let source = initial;\n  let track;\n  let trigger;\n  const ref = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        return get();\n      },\n      set(v) {\n        set(v);\n      }\n    };\n  });\n  function get(tracking = true) {\n    if (tracking)\n      track();\n    return source;\n  }\n  function set(value, triggering = true) {\n    var _a, _b;\n    if (value === source)\n      return;\n    const old = source;\n    if (((_a = options.onBeforeChange) == null ? void 0 : _a.call(options, value, old)) === false)\n      return;\n    source = value;\n    (_b = options.onChanged) == null ? void 0 : _b.call(options, value, old);\n    if (triggering)\n      trigger();\n  }\n  const untrackedGet = () => get(false);\n  const silentSet = (v) => set(v, false);\n  const peek = () => get(false);\n  const lay = (v) => set(v, false);\n  return extendRef(\n    ref,\n    {\n      get,\n      set,\n      untrackedGet,\n      silentSet,\n      peek,\n      lay\n    },\n    { enumerable: true }\n  );\n}\nconst controlledRef = refWithControl;\n\nfunction set(...args) {\n  if (args.length === 2) {\n    const [ref, value] = args;\n    ref.value = value;\n  }\n  if (args.length === 3) {\n    if (isVue2) {\n      set$1(...args);\n    } else {\n      const [target, key, value] = args;\n      target[key] = value;\n    }\n  }\n}\n\nfunction watchWithFilter(source, cb, options = {}) {\n  const {\n    eventFilter = bypassFilter,\n    ...watchOptions\n  } = options;\n  return watch(\n    source,\n    createFilterWrapper(\n      eventFilter,\n      cb\n    ),\n    watchOptions\n  );\n}\n\nfunction watchPausable(source, cb, options = {}) {\n  const {\n    eventFilter: filter,\n    ...watchOptions\n  } = options;\n  const { eventFilter, pause, resume, isActive } = pausableFilter(filter);\n  const stop = watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter\n    }\n  );\n  return { stop, pause, resume, isActive };\n}\n\nfunction syncRef(left, right, ...[options]) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true,\n    direction = \"both\",\n    transform = {}\n  } = options || {};\n  const watchers = [];\n  const transformLTR = \"ltr\" in transform && transform.ltr || ((v) => v);\n  const transformRTL = \"rtl\" in transform && transform.rtl || ((v) => v);\n  if (direction === \"both\" || direction === \"ltr\") {\n    watchers.push(watchPausable(\n      left,\n      (newValue) => {\n        watchers.forEach((w) => w.pause());\n        right.value = transformLTR(newValue);\n        watchers.forEach((w) => w.resume());\n      },\n      { flush, deep, immediate }\n    ));\n  }\n  if (direction === \"both\" || direction === \"rtl\") {\n    watchers.push(watchPausable(\n      right,\n      (newValue) => {\n        watchers.forEach((w) => w.pause());\n        left.value = transformRTL(newValue);\n        watchers.forEach((w) => w.resume());\n      },\n      { flush, deep, immediate }\n    ));\n  }\n  const stop = () => {\n    watchers.forEach((w) => w.stop());\n  };\n  return stop;\n}\n\nfunction syncRefs(source, targets, options = {}) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true\n  } = options;\n  if (!Array.isArray(targets))\n    targets = [targets];\n  return watch(\n    source,\n    (newValue) => targets.forEach((target) => target.value = newValue),\n    { flush, deep, immediate }\n  );\n}\n\nfunction toRefs(objectRef, options = {}) {\n  if (!isRef(objectRef))\n    return toRefs$1(objectRef);\n  const result = Array.isArray(objectRef.value) ? Array.from({ length: objectRef.value.length }) : {};\n  for (const key in objectRef.value) {\n    result[key] = customRef(() => ({\n      get() {\n        return objectRef.value[key];\n      },\n      set(v) {\n        var _a;\n        const replaceRef = (_a = toValue(options.replaceRef)) != null ? _a : true;\n        if (replaceRef) {\n          if (Array.isArray(objectRef.value)) {\n            const copy = [...objectRef.value];\n            copy[key] = v;\n            objectRef.value = copy;\n          } else {\n            const newObject = { ...objectRef.value, [key]: v };\n            Object.setPrototypeOf(newObject, Object.getPrototypeOf(objectRef.value));\n            objectRef.value = newObject;\n          }\n        } else {\n          objectRef.value[key] = v;\n        }\n      }\n    }));\n  }\n  return result;\n}\n\nfunction tryOnBeforeMount(fn, sync = true, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onBeforeMount(fn, target);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnBeforeUnmount(fn, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onBeforeUnmount(fn, target);\n}\n\nfunction tryOnMounted(fn, sync = true, target) {\n  const instance = getLifeCycleTarget();\n  if (instance)\n    onMounted(fn, target);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnUnmounted(fn, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onUnmounted(fn, target);\n}\n\nfunction createUntil(r, isNot = false) {\n  function toMatch(condition, { flush = \"sync\", deep = false, timeout, throwOnTimeout } = {}) {\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch(\n        r,\n        (v) => {\n          if (condition(v) !== isNot) {\n            stop == null ? void 0 : stop();\n            resolve(v);\n          }\n        },\n        {\n          flush,\n          deep,\n          immediate: true\n        }\n      );\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(\n        promiseTimeout(timeout, throwOnTimeout).then(() => toValue(r)).finally(() => stop == null ? void 0 : stop())\n      );\n    }\n    return Promise.race(promises);\n  }\n  function toBe(value, options) {\n    if (!isRef(value))\n      return toMatch((v) => v === value, options);\n    const { flush = \"sync\", deep = false, timeout, throwOnTimeout } = options != null ? options : {};\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch(\n        [r, value],\n        ([v1, v2]) => {\n          if (isNot !== (v1 === v2)) {\n            stop == null ? void 0 : stop();\n            resolve(v1);\n          }\n        },\n        {\n          flush,\n          deep,\n          immediate: true\n        }\n      );\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(\n        promiseTimeout(timeout, throwOnTimeout).then(() => toValue(r)).finally(() => {\n          stop == null ? void 0 : stop();\n          return toValue(r);\n        })\n      );\n    }\n    return Promise.race(promises);\n  }\n  function toBeTruthy(options) {\n    return toMatch((v) => Boolean(v), options);\n  }\n  function toBeNull(options) {\n    return toBe(null, options);\n  }\n  function toBeUndefined(options) {\n    return toBe(void 0, options);\n  }\n  function toBeNaN(options) {\n    return toMatch(Number.isNaN, options);\n  }\n  function toContains(value, options) {\n    return toMatch((v) => {\n      const array = Array.from(v);\n      return array.includes(value) || array.includes(toValue(value));\n    }, options);\n  }\n  function changed(options) {\n    return changedTimes(1, options);\n  }\n  function changedTimes(n = 1, options) {\n    let count = -1;\n    return toMatch(() => {\n      count += 1;\n      return count >= n;\n    }, options);\n  }\n  if (Array.isArray(toValue(r))) {\n    const instance = {\n      toMatch,\n      toContains,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  } else {\n    const instance = {\n      toMatch,\n      toBe,\n      toBeTruthy,\n      toBeNull,\n      toBeNaN,\n      toBeUndefined,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  }\n}\nfunction until(r) {\n  return createUntil(r);\n}\n\nfunction defaultComparator(value, othVal) {\n  return value === othVal;\n}\nfunction useArrayDifference(...args) {\n  var _a;\n  const list = args[0];\n  const values = args[1];\n  let compareFn = (_a = args[2]) != null ? _a : defaultComparator;\n  if (typeof compareFn === \"string\") {\n    const key = compareFn;\n    compareFn = (value, othVal) => value[key] === othVal[key];\n  }\n  return computed(() => toValue(list).filter((x) => toValue(values).findIndex((y) => compareFn(x, y)) === -1));\n}\n\nfunction useArrayEvery(list, fn) {\n  return computed(() => toValue(list).every((element, index, array) => fn(toValue(element), index, array)));\n}\n\nfunction useArrayFilter(list, fn) {\n  return computed(() => toValue(list).map((i) => toValue(i)).filter(fn));\n}\n\nfunction useArrayFind(list, fn) {\n  return computed(() => toValue(\n    toValue(list).find((element, index, array) => fn(toValue(element), index, array))\n  ));\n}\n\nfunction useArrayFindIndex(list, fn) {\n  return computed(() => toValue(list).findIndex((element, index, array) => fn(toValue(element), index, array)));\n}\n\nfunction findLast(arr, cb) {\n  let index = arr.length;\n  while (index-- > 0) {\n    if (cb(arr[index], index, arr))\n      return arr[index];\n  }\n  return void 0;\n}\nfunction useArrayFindLast(list, fn) {\n  return computed(() => toValue(\n    !Array.prototype.findLast ? findLast(toValue(list), (element, index, array) => fn(toValue(element), index, array)) : toValue(list).findLast((element, index, array) => fn(toValue(element), index, array))\n  ));\n}\n\nfunction isArrayIncludesOptions(obj) {\n  return isObject(obj) && containsProp(obj, \"formIndex\", \"comparator\");\n}\nfunction useArrayIncludes(...args) {\n  var _a;\n  const list = args[0];\n  const value = args[1];\n  let comparator = args[2];\n  let formIndex = 0;\n  if (isArrayIncludesOptions(comparator)) {\n    formIndex = (_a = comparator.fromIndex) != null ? _a : 0;\n    comparator = comparator.comparator;\n  }\n  if (typeof comparator === \"string\") {\n    const key = comparator;\n    comparator = (element, value2) => element[key] === toValue(value2);\n  }\n  comparator = comparator != null ? comparator : (element, value2) => element === toValue(value2);\n  return computed(() => toValue(list).slice(formIndex).some((element, index, array) => comparator(\n    toValue(element),\n    toValue(value),\n    index,\n    toValue(array)\n  )));\n}\n\nfunction useArrayJoin(list, separator) {\n  return computed(() => toValue(list).map((i) => toValue(i)).join(toValue(separator)));\n}\n\nfunction useArrayMap(list, fn) {\n  return computed(() => toValue(list).map((i) => toValue(i)).map(fn));\n}\n\nfunction useArrayReduce(list, reducer, ...args) {\n  const reduceCallback = (sum, value, index) => reducer(toValue(sum), toValue(value), index);\n  return computed(() => {\n    const resolved = toValue(list);\n    return args.length ? resolved.reduce(reduceCallback, toValue(args[0])) : resolved.reduce(reduceCallback);\n  });\n}\n\nfunction useArraySome(list, fn) {\n  return computed(() => toValue(list).some((element, index, array) => fn(toValue(element), index, array)));\n}\n\nfunction uniq(array) {\n  return Array.from(new Set(array));\n}\nfunction uniqueElementsBy(array, fn) {\n  return array.reduce((acc, v) => {\n    if (!acc.some((x) => fn(v, x, array)))\n      acc.push(v);\n    return acc;\n  }, []);\n}\nfunction useArrayUnique(list, compareFn) {\n  return computed(() => {\n    const resolvedList = toValue(list).map((element) => toValue(element));\n    return compareFn ? uniqueElementsBy(resolvedList, compareFn) : uniq(resolvedList);\n  });\n}\n\nfunction useCounter(initialValue = 0, options = {}) {\n  let _initialValue = unref(initialValue);\n  const count = ref(initialValue);\n  const {\n    max = Number.POSITIVE_INFINITY,\n    min = Number.NEGATIVE_INFINITY\n  } = options;\n  const inc = (delta = 1) => count.value = Math.max(Math.min(max, count.value + delta), min);\n  const dec = (delta = 1) => count.value = Math.min(Math.max(min, count.value - delta), max);\n  const get = () => count.value;\n  const set = (val) => count.value = Math.max(min, Math.min(max, val));\n  const reset = (val = _initialValue) => {\n    _initialValue = val;\n    return set(val);\n  };\n  return { count, inc, dec, get, set, reset };\n}\n\nconst REGEX_PARSE = /^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[Tt\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/;\nconst REGEX_FORMAT = /[YMDHhms]o|\\[([^\\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|SSS/g;\nfunction defaultMeridiem(hours, minutes, isLowercase, hasPeriod) {\n  let m = hours < 12 ? \"AM\" : \"PM\";\n  if (hasPeriod)\n    m = m.split(\"\").reduce((acc, curr) => acc += `${curr}.`, \"\");\n  return isLowercase ? m.toLowerCase() : m;\n}\nfunction formatOrdinal(num) {\n  const suffixes = [\"th\", \"st\", \"nd\", \"rd\"];\n  const v = num % 100;\n  return num + (suffixes[(v - 20) % 10] || suffixes[v] || suffixes[0]);\n}\nfunction formatDate(date, formatStr, options = {}) {\n  var _a;\n  const years = date.getFullYear();\n  const month = date.getMonth();\n  const days = date.getDate();\n  const hours = date.getHours();\n  const minutes = date.getMinutes();\n  const seconds = date.getSeconds();\n  const milliseconds = date.getMilliseconds();\n  const day = date.getDay();\n  const meridiem = (_a = options.customMeridiem) != null ? _a : defaultMeridiem;\n  const matches = {\n    Yo: () => formatOrdinal(years),\n    YY: () => String(years).slice(-2),\n    YYYY: () => years,\n    M: () => month + 1,\n    Mo: () => formatOrdinal(month + 1),\n    MM: () => `${month + 1}`.padStart(2, \"0\"),\n    MMM: () => date.toLocaleDateString(options.locales, { month: \"short\" }),\n    MMMM: () => date.toLocaleDateString(options.locales, { month: \"long\" }),\n    D: () => String(days),\n    Do: () => formatOrdinal(days),\n    DD: () => `${days}`.padStart(2, \"0\"),\n    H: () => String(hours),\n    Ho: () => formatOrdinal(hours),\n    HH: () => `${hours}`.padStart(2, \"0\"),\n    h: () => `${hours % 12 || 12}`.padStart(1, \"0\"),\n    ho: () => formatOrdinal(hours % 12 || 12),\n    hh: () => `${hours % 12 || 12}`.padStart(2, \"0\"),\n    m: () => String(minutes),\n    mo: () => formatOrdinal(minutes),\n    mm: () => `${minutes}`.padStart(2, \"0\"),\n    s: () => String(seconds),\n    so: () => formatOrdinal(seconds),\n    ss: () => `${seconds}`.padStart(2, \"0\"),\n    SSS: () => `${milliseconds}`.padStart(3, \"0\"),\n    d: () => day,\n    dd: () => date.toLocaleDateString(options.locales, { weekday: \"narrow\" }),\n    ddd: () => date.toLocaleDateString(options.locales, { weekday: \"short\" }),\n    dddd: () => date.toLocaleDateString(options.locales, { weekday: \"long\" }),\n    A: () => meridiem(hours, minutes),\n    AA: () => meridiem(hours, minutes, false, true),\n    a: () => meridiem(hours, minutes, true),\n    aa: () => meridiem(hours, minutes, true, true)\n  };\n  return formatStr.replace(REGEX_FORMAT, (match, $1) => {\n    var _a2, _b;\n    return (_b = $1 != null ? $1 : (_a2 = matches[match]) == null ? void 0 : _a2.call(matches)) != null ? _b : match;\n  });\n}\nfunction normalizeDate(date) {\n  if (date === null)\n    return new Date(Number.NaN);\n  if (date === void 0)\n    return /* @__PURE__ */ new Date();\n  if (date instanceof Date)\n    return new Date(date);\n  if (typeof date === \"string\" && !/Z$/i.test(date)) {\n    const d = date.match(REGEX_PARSE);\n    if (d) {\n      const m = d[2] - 1 || 0;\n      const ms = (d[7] || \"0\").substring(0, 3);\n      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);\n    }\n  }\n  return new Date(date);\n}\nfunction useDateFormat(date, formatStr = \"HH:mm:ss\", options = {}) {\n  return computed(() => formatDate(normalizeDate(toValue(date)), toValue(formatStr), options));\n}\n\nfunction useIntervalFn(cb, interval = 1e3, options = {}) {\n  const {\n    immediate = true,\n    immediateCallback = false\n  } = options;\n  let timer = null;\n  const isActive = ref(false);\n  function clean() {\n    if (timer) {\n      clearInterval(timer);\n      timer = null;\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    clean();\n  }\n  function resume() {\n    const intervalValue = toValue(interval);\n    if (intervalValue <= 0)\n      return;\n    isActive.value = true;\n    if (immediateCallback)\n      cb();\n    clean();\n    timer = setInterval(cb, intervalValue);\n  }\n  if (immediate && isClient)\n    resume();\n  if (isRef(interval) || typeof interval === \"function\") {\n    const stopWatch = watch(interval, () => {\n      if (isActive.value && isClient)\n        resume();\n    });\n    tryOnScopeDispose(stopWatch);\n  }\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nfunction useInterval(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    immediate = true,\n    callback\n  } = options;\n  const counter = ref(0);\n  const update = () => counter.value += 1;\n  const reset = () => {\n    counter.value = 0;\n  };\n  const controls = useIntervalFn(\n    callback ? () => {\n      update();\n      callback(counter.value);\n    } : update,\n    interval,\n    { immediate }\n  );\n  if (exposeControls) {\n    return {\n      counter,\n      reset,\n      ...controls\n    };\n  } else {\n    return counter;\n  }\n}\n\nfunction useLastChanged(source, options = {}) {\n  var _a;\n  const ms = ref((_a = options.initialValue) != null ? _a : null);\n  watch(\n    source,\n    () => ms.value = timestamp(),\n    options\n  );\n  return ms;\n}\n\nfunction useTimeoutFn(cb, interval, options = {}) {\n  const {\n    immediate = true\n  } = options;\n  const isPending = ref(false);\n  let timer = null;\n  function clear() {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n  }\n  function stop() {\n    isPending.value = false;\n    clear();\n  }\n  function start(...args) {\n    clear();\n    isPending.value = true;\n    timer = setTimeout(() => {\n      isPending.value = false;\n      timer = null;\n      cb(...args);\n    }, toValue(interval));\n  }\n  if (immediate) {\n    isPending.value = true;\n    if (isClient)\n      start();\n  }\n  tryOnScopeDispose(stop);\n  return {\n    isPending: readonly(isPending),\n    start,\n    stop\n  };\n}\n\nfunction useTimeout(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    callback\n  } = options;\n  const controls = useTimeoutFn(\n    callback != null ? callback : noop,\n    interval,\n    options\n  );\n  const ready = computed(() => !controls.isPending.value);\n  if (exposeControls) {\n    return {\n      ready,\n      ...controls\n    };\n  } else {\n    return ready;\n  }\n}\n\nfunction useToNumber(value, options = {}) {\n  const {\n    method = \"parseFloat\",\n    radix,\n    nanToZero\n  } = options;\n  return computed(() => {\n    let resolved = toValue(value);\n    if (typeof resolved === \"string\")\n      resolved = Number[method](resolved, radix);\n    if (nanToZero && Number.isNaN(resolved))\n      resolved = 0;\n    return resolved;\n  });\n}\n\nfunction useToString(value) {\n  return computed(() => `${toValue(value)}`);\n}\n\nfunction useToggle(initialValue = false, options = {}) {\n  const {\n    truthyValue = true,\n    falsyValue = false\n  } = options;\n  const valueIsRef = isRef(initialValue);\n  const _value = ref(initialValue);\n  function toggle(value) {\n    if (arguments.length) {\n      _value.value = value;\n      return _value.value;\n    } else {\n      const truthy = toValue(truthyValue);\n      _value.value = _value.value === truthy ? toValue(falsyValue) : truthy;\n      return _value.value;\n    }\n  }\n  if (valueIsRef)\n    return toggle;\n  else\n    return [_value, toggle];\n}\n\nfunction watchArray(source, cb, options) {\n  let oldList = (options == null ? void 0 : options.immediate) ? [] : [...source instanceof Function ? source() : Array.isArray(source) ? source : toValue(source)];\n  return watch(source, (newList, _, onCleanup) => {\n    const oldListRemains = Array.from({ length: oldList.length });\n    const added = [];\n    for (const obj of newList) {\n      let found = false;\n      for (let i = 0; i < oldList.length; i++) {\n        if (!oldListRemains[i] && obj === oldList[i]) {\n          oldListRemains[i] = true;\n          found = true;\n          break;\n        }\n      }\n      if (!found)\n        added.push(obj);\n    }\n    const removed = oldList.filter((_2, i) => !oldListRemains[i]);\n    cb(newList, oldList, added, removed, onCleanup);\n    oldList = [...newList];\n  }, options);\n}\n\nfunction watchAtMost(source, cb, options) {\n  const {\n    count,\n    ...watchOptions\n  } = options;\n  const current = ref(0);\n  const stop = watchWithFilter(\n    source,\n    (...args) => {\n      current.value += 1;\n      if (current.value >= toValue(count))\n        nextTick(() => stop());\n      cb(...args);\n    },\n    watchOptions\n  );\n  return { count: current, stop };\n}\n\nfunction watchDebounced(source, cb, options = {}) {\n  const {\n    debounce = 0,\n    maxWait = void 0,\n    ...watchOptions\n  } = options;\n  return watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter: debounceFilter(debounce, { maxWait })\n    }\n  );\n}\n\nfunction watchDeep(source, cb, options) {\n  return watch(\n    source,\n    cb,\n    {\n      ...options,\n      deep: true\n    }\n  );\n}\n\nfunction watchIgnorable(source, cb, options = {}) {\n  const {\n    eventFilter = bypassFilter,\n    ...watchOptions\n  } = options;\n  const filteredCb = createFilterWrapper(\n    eventFilter,\n    cb\n  );\n  let ignoreUpdates;\n  let ignorePrevAsyncUpdates;\n  let stop;\n  if (watchOptions.flush === \"sync\") {\n    const ignore = ref(false);\n    ignorePrevAsyncUpdates = () => {\n    };\n    ignoreUpdates = (updater) => {\n      ignore.value = true;\n      updater();\n      ignore.value = false;\n    };\n    stop = watch(\n      source,\n      (...args) => {\n        if (!ignore.value)\n          filteredCb(...args);\n      },\n      watchOptions\n    );\n  } else {\n    const disposables = [];\n    const ignoreCounter = ref(0);\n    const syncCounter = ref(0);\n    ignorePrevAsyncUpdates = () => {\n      ignoreCounter.value = syncCounter.value;\n    };\n    disposables.push(\n      watch(\n        source,\n        () => {\n          syncCounter.value++;\n        },\n        { ...watchOptions, flush: \"sync\" }\n      )\n    );\n    ignoreUpdates = (updater) => {\n      const syncCounterPrev = syncCounter.value;\n      updater();\n      ignoreCounter.value += syncCounter.value - syncCounterPrev;\n    };\n    disposables.push(\n      watch(\n        source,\n        (...args) => {\n          const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;\n          ignoreCounter.value = 0;\n          syncCounter.value = 0;\n          if (ignore)\n            return;\n          filteredCb(...args);\n        },\n        watchOptions\n      )\n    );\n    stop = () => {\n      disposables.forEach((fn) => fn());\n    };\n  }\n  return { stop, ignoreUpdates, ignorePrevAsyncUpdates };\n}\n\nfunction watchImmediate(source, cb, options) {\n  return watch(\n    source,\n    cb,\n    {\n      ...options,\n      immediate: true\n    }\n  );\n}\n\nfunction watchOnce(source, cb, options) {\n  const stop = watch(source, (...args) => {\n    nextTick(() => stop());\n    return cb(...args);\n  }, options);\n  return stop;\n}\n\nfunction watchThrottled(source, cb, options = {}) {\n  const {\n    throttle = 0,\n    trailing = true,\n    leading = true,\n    ...watchOptions\n  } = options;\n  return watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter: throttleFilter(throttle, trailing, leading)\n    }\n  );\n}\n\nfunction watchTriggerable(source, cb, options = {}) {\n  let cleanupFn;\n  function onEffect() {\n    if (!cleanupFn)\n      return;\n    const fn = cleanupFn;\n    cleanupFn = void 0;\n    fn();\n  }\n  function onCleanup(callback) {\n    cleanupFn = callback;\n  }\n  const _cb = (value, oldValue) => {\n    onEffect();\n    return cb(value, oldValue, onCleanup);\n  };\n  const res = watchIgnorable(source, _cb, options);\n  const { ignoreUpdates } = res;\n  const trigger = () => {\n    let res2;\n    ignoreUpdates(() => {\n      res2 = _cb(getWatchSources(source), getOldValue(source));\n    });\n    return res2;\n  };\n  return {\n    ...res,\n    trigger\n  };\n}\nfunction getWatchSources(sources) {\n  if (isReactive(sources))\n    return sources;\n  if (Array.isArray(sources))\n    return sources.map((item) => toValue(item));\n  return toValue(sources);\n}\nfunction getOldValue(source) {\n  return Array.isArray(source) ? source.map(() => void 0) : void 0;\n}\n\nfunction whenever(source, cb, options) {\n  return watch(\n    source,\n    (v, ov, onInvalidate) => {\n      if (v)\n        cb(v, ov, onInvalidate);\n    },\n    options\n  );\n}\n\nexport { assert, refAutoReset as autoResetRef, bypassFilter, camelize, clamp, computedEager, computedWithControl, containsProp, computedWithControl as controlledComputed, controlledRef, createEventHook, createFilterWrapper, createGlobalState, createInjectionState, reactify as createReactiveFn, createSharedComposable, createSingletonPromise, debounceFilter, refDebounced as debouncedRef, watchDebounced as debouncedWatch, directiveHooks, computedEager as eagerComputed, extendRef, formatDate, get, getLifeCycleTarget, hasOwn, hyphenate, identity, watchIgnorable as ignorableWatch, increaseWithUnit, injectLocal, invoke, isClient, isDef, isDefined, isIOS, isObject, isWorker, makeDestructurable, noop, normalizeDate, notNullish, now, objectEntries, objectOmit, objectPick, pausableFilter, watchPausable as pausableWatch, promiseTimeout, provideLocal, rand, reactify, reactifyObject, reactiveComputed, reactiveOmit, reactivePick, refAutoReset, refDebounced, refDefault, refThrottled, refWithControl, resolveRef, resolveUnref, set, syncRef, syncRefs, throttleFilter, refThrottled as throttledRef, watchThrottled as throttledWatch, timestamp, toReactive, toRef, toRefs, toValue, tryOnBeforeMount, tryOnBeforeUnmount, tryOnMounted, tryOnScopeDispose, tryOnUnmounted, until, useArrayDifference, useArrayEvery, useArrayFilter, useArrayFind, useArrayFindIndex, useArrayFindLast, useArrayIncludes, useArrayJoin, useArrayMap, useArrayReduce, useArraySome, useArrayUnique, useCounter, useDateFormat, refDebounced as useDebounce, useDebounceFn, useInterval, useIntervalFn, useLastChanged, refThrottled as useThrottle, useThrottleFn, useTimeout, useTimeoutFn, useToNumber, useToString, useToggle, watchArray, watchAtMost, watchDebounced, watchDeep, watchIgnorable, watchImmediate, watchOnce, watchPausable, watchThrottled, watchTriggerable, watchWithFilter, whenever };\n","'use strict';\n\nmodule.exports = function (data, opts) {\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (node) {\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        if (node === undefined) return;\n        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';\n        if (typeof node !== 'object') return JSON.stringify(node);\n\n        var i, out;\n        if (Array.isArray(node)) {\n            out = '[';\n            for (i = 0; i < node.length; i++) {\n                if (i) out += ',';\n                out += stringify(node[i]) || 'null';\n            }\n            return out + ']';\n        }\n\n        if (node === null) return 'null';\n\n        if (seen.indexOf(node) !== -1) {\n            if (cycles) return JSON.stringify('__cycle__');\n            throw new TypeError('Converting circular structure to JSON');\n        }\n\n        var seenIndex = seen.push(node) - 1;\n        var keys = Object.keys(node).sort(cmp && cmp(node));\n        out = '';\n        for (i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            var value = stringify(node[key]);\n\n            if (!value) continue;\n            if (out) out += ',';\n            out += JSON.stringify(key) + ':' + value;\n        }\n        seen.splice(seenIndex, 1);\n        return '{' + out + '}';\n    })(data);\n};\n","import type { MaybeRef } from '@vueuse/core'\nimport type { Ref } from 'vue-demi'\nimport { _ } from '@feathersjs/commons'\nimport { unref } from 'vue-demi'\nimport type { Params, Query } from '../types.js'\nimport type { UseFindParams } from './types.js'\n\nexport function makeParamsWithoutPage(params: MaybeRef<UseFindParams>) {\n  params = unref(params)\n  const query = _.omit(params.query, '$limit', '$skip')\n  const newParams = _.omit(params, 'query', 'store')\n  return { ...newParams, query }\n}\n\n// Updates the _params with everything from _newParams except `$limit` and `$skip`\nexport function updateParamsExcludePage(_params: Ref<UseFindParams>, _newParams: MaybeRef<UseFindParams>) {\n  _params.value.query = {\n    ...unref(_newParams).query,\n    ..._.pick(unref(_params).query, '$limit', '$skip'),\n  }\n}\n\nexport function getIdsFromQueryInfo(pagination: any, queryInfo: any): any[] {\n  const { queryId, pageId } = queryInfo\n  const queryLevel = pagination[queryId]\n  const pageLevel = queryLevel && queryLevel[pageId]\n  const ids = pageLevel && pageLevel.ids\n\n  return ids || []\n}\n\n/**\n * A wrapper for findInStore that can return server-paginated data\n */\nexport function itemsFromPagination(store: any, service: any, params: Params<Query>) {\n  const qid = params.qid || 'default'\n  const pagination = store.pagination[qid] || {}\n  const queryInfo = store.getQueryInfo(params)\n  const ids = getIdsFromQueryInfo(pagination, queryInfo)\n  const items = ids\n    .map((id) => {\n      const fromStore = service.getFromStore(id).value\n      return fromStore\n    })\n    .filter(i => i) // filter out undefined values\n  return items\n}\n","import type { Ref } from 'vue-demi'\nimport { computed } from 'vue-demi'\nimport { timeout } from '../utils/index.js'\n\ninterface Options {\n  limit: Ref<number>\n  skip: Ref<number>\n  total: Ref<number>\n  request?: any\n}\n\nexport function usePageData(options: Options) {\n  const { limit, skip, total, request } = options\n  /**\n   * The number of pages available based on the results returned in the latestQuery prop.\n   */\n  const pageCount = computed(() => {\n    if (total.value)\n      return Math.ceil(total.value / limit.value)\n    else return 1\n  })\n\n  // Uses Math.floor so we can't land on a non-integer page like 1.4\n  const currentPage = computed({\n    set(pageNumber: number) {\n      if (pageNumber < 1)\n        pageNumber = 1\n      else if (pageNumber > pageCount.value)\n        pageNumber = pageCount.value\n      const newSkip = limit.value * Math.floor(pageNumber - 1)\n      skip.value = newSkip\n    },\n    get() {\n      const skipVal = skip.value || 0\n      return pageCount.value === 0 ? 0 : Math.floor(skipVal / limit.value + 1)\n    },\n  })\n\n  const canPrev = computed(() => {\n    return currentPage.value - 1 > 0\n  })\n  const canNext = computed(() => {\n    return currentPage.value < pageCount.value\n  })\n\n  const wait = async () => {\n    if (request?.value)\n      await request.value\n  }\n  const toStart = async () => {\n    currentPage.value = 1\n    await timeout(0)\n    return wait()\n  }\n  const toEnd = async () => {\n    currentPage.value = pageCount.value\n    await timeout(0)\n    return wait()\n  }\n  const toPage = async (page: number) => {\n    currentPage.value = page\n    await timeout(0)\n    return wait()\n  }\n  const next = async () => {\n    currentPage.value++\n    await timeout(0)\n    return wait()\n  }\n  const prev = async () => {\n    currentPage.value--\n    await timeout(0)\n    return wait()\n  }\n\n  return { pageCount, currentPage, canPrev, canNext, toStart, toEnd, toPage, next, prev }\n}\n","import type { ComputedRef, Ref, UnwrapNestedRefs, WritableComputedRef } from 'vue-demi'\nimport { computed, reactive, ref, unref, watch } from 'vue-demi'\nimport { _ } from '@feathersjs/commons'\nimport { useDebounceFn } from '@vueuse/core'\nimport stringify from 'fast-json-stable-stringify'\nimport { deepUnref, getExtendedQueryInfo } from '../utils/index.js'\nimport type { AnyData, ExtendedQueryInfo, Paginated, Params, Query } from '../types.js'\nimport { itemsFromPagination } from './utils.js'\nimport { usePageData } from './utils-pagination.js'\nimport type { UseFindGetDeps, UseFindOptions, UseFindParams } from './types.js'\n\nexport type UseFindReturn<M = AnyData> = UnwrapNestedRefs<{\n  paramsWithPagination: ComputedRef<Params<Query>>\n  isSsr: ComputedRef<boolean>\n  qid: WritableComputedRef<string>\n\n  data: ComputedRef<M[]>\n  allLocalData: ComputedRef<M[]>\n  total: ComputedRef<number>\n  limit: Ref<number>\n  skip: number\n\n  currentQuery: ComputedRef<ExtendedQueryInfo | null>\n  cachedQuery: ComputedRef<ExtendedQueryInfo | null>\n  latestQuery: ComputedRef<ExtendedQueryInfo | null>\n  previousQuery: ComputedRef<ExtendedQueryInfo | null>\n\n  find: () => Promise<void>\n  request: Ref<Promise<Paginated<M>> | null>\n  requestCount: Ref<number>\n  queryWhen: (queryWhenFn: () => boolean) => void\n\n  isPending: ComputedRef<boolean>\n  haveBeenRequested: ComputedRef<boolean>\n  haveLoaded: ComputedRef<boolean>\n  error: ComputedRef<any>\n  clearError: () => void\n\n  pageCount: Ref<number>\n  currentPage: Ref<number>\n  canPrev: ComputedRef<boolean>\n  canNext: ComputedRef<boolean>\n  next: () => Promise<void>\n  prev: () => Promise<void>\n  toStart: () => Promise<void>\n  toEnd: () => Promise<void>\n  toPage: (page: number) => Promise<void>\n}>\n\nexport function useFind<M = AnyData>(params: ComputedRef<UseFindParams | null>, options: UseFindOptions = {}, deps: UseFindGetDeps): UseFindReturn<M> {\n  const { pagination, debounce = 100, immediate = true, watch: _watch = true, paginateOn = 'client' } = options\n  const { service } = deps\n  const { store } = service\n\n  /** PARAMS */\n  const qid = computed(() => params.value?.qid || 'default')\n  const limit = pagination?.limit || ref(params.value?.query?.$limit || store.defaultLimit)\n  const skip = pagination?.skip || ref(params.value?.query?.$skip || 0)\n\n  const paramsWithPagination = computed<Params<Query>>(() => {\n    const query = deepUnref(params.value?.query || {})\n    return {\n      ...params.value,\n      query: {\n        ...query,\n        $limit: limit.value,\n        $skip: skip.value,\n      },\n    }\n  })\n  const paramsWithoutPagination = computed(() => {\n    const queryShallowCopy = deepUnref(params.value?.query || {})\n    const query = _.omit(queryShallowCopy, '$limit', '$skip')\n    const newParams = { ...params.value, query }\n    return newParams\n  })\n\n  /** REQUEST STATE */\n  const isPending = ref(false)\n  const haveBeenRequested = ref(false)\n  const haveLoaded = ref(false)\n  const error = ref<any>(null)\n  const clearError = () => (error.value = null)\n\n  /** Cached Params */\n  const cachedParams = ref(deepUnref(params.value || {}))\n  function updateCachedParams() {\n    if (stringify(cachedParams.value) !== stringify(paramsWithPagination.value))\n      cachedParams.value = paramsWithPagination.value\n  }\n\n  /** QUERY WHEN */\n  let queryWhenFn = () => true\n  const queryWhen = (_queryWhenFn: () => boolean) => {\n    queryWhenFn = _queryWhenFn\n  }\n  // returns cached query data from the store BEFORE the request is sent.\n  const cachedQuery = computed(() => {\n    const qidState: any = store.pagination[qid.value]\n    if (!qidState)\n      return null\n\n    const queryInfo = store.getQueryInfo(cachedParams.value)\n    const extendedInfo = getExtendedQueryInfo({ queryInfo, service, store, qid })\n    return extendedInfo\n  })\n\n  const currentQuery = computed(() => {\n    const qidState: any = store.pagination[qid.value]\n    if (!qidState)\n      return null\n\n    const queryInfo = store.getQueryInfo(paramsWithPagination.value)\n    const extendedInfo = getExtendedQueryInfo({ queryInfo, service, store, qid })\n    return extendedInfo\n  })\n\n  const allLocalData = computed(() => {\n    const whichQuery = isPending.value ? cachedQuery.value : currentQuery.value\n    if (whichQuery == null && paginateOn !== 'client')\n      return []\n\n    const allItems = service.findInStore(deepUnref(paramsWithoutPagination.value)).data\n    return allItems\n  })\n  const itemsBeforeCurrent = computed(() => {\n    const whichQuery = isPending.value ? cachedQuery.value : currentQuery.value\n    if (whichQuery == null)\n      return []\n\n    const allItems = allLocalData.value\n    const firstOfCurrentPage = whichQuery.items.find((i: any) => i)\n    const indexInItems = allItems.findIndex((i: any) => i[store.idField] === firstOfCurrentPage[store.idField])\n    // if indexInItems is higher than skip, use the skip value instead\n    const adjustedIndex = Math.min(indexInItems, skip.value)\n    const beforeCurrent = allItems.slice(0, adjustedIndex)\n    return beforeCurrent\n  })\n\n  /** STORE ITEMS */\n  const localParams = computed(() => {\n    const beforeCurrent = itemsBeforeCurrent.value\n    const adjustedSkip = skip.value + (beforeCurrent.length - skip.value)\n    const params = {\n      ...paramsWithPagination.value,\n      query: {\n        ...paramsWithPagination.value.query,\n        $limit: limit.value,\n        $skip: adjustedSkip,\n      },\n    }\n    return params\n  })\n\n  const data = computed<M[]>(() => {\n    if (paginateOn === 'server') {\n      const values = itemsFromPagination(store, service, cachedParams.value)\n      return values\n    }\n    else if (paginateOn === 'hybrid') {\n      const result = service.findInStore(deepUnref(localParams)).data\n      return result.filter((i: any) => i)\n    }\n    else {\n      const result = service.findInStore(deepUnref(paramsWithPagination)).data\n      return result.filter((i: any) => i)\n    }\n  })\n\n  /** QUERIES */\n  const queries: Ref<ExtendedQueryInfo[]> = ref([]) // query info after the response returns\n  const latestQuery = computed(() => {\n    return queries.value[queries.value.length - 1] || null\n  })\n  const previousQuery = computed(() => {\n    return queries.value[queries.value.length - 2] || null\n  })\n\n  /** SERVER FETCHING */\n  const requestCount = ref(0)\n  const request = ref<Promise<Paginated<M>> | null>(null)\n\n  // pulled into its own function so it can be called from `makeRequest` or `find`\n  function setupPendingState() {\n    // prevent setting pending state for cached ssr requests\n    if (currentQuery.value?.ssr)\n      return\n\n    if (!haveBeenRequested.value)\n      haveBeenRequested.value = true // never resets\n    clearError()\n    if (!isPending.value)\n      isPending.value = true\n    if (haveLoaded.value)\n      haveLoaded.value = false\n  }\n\n  async function find(__params?: Params<Query>) {\n    // When `paginateOn: 'server'` is enabled, the computed params will always be used, __params ignored.\n    const ___params = unref(\n      __params != null\n        ? __params\n        : paginateOn === 'client'\n          ? paramsWithoutPagination.value\n          : paramsWithPagination.value,\n    )\n\n    // if queryWhen is falsey, return early with dummy data\n    if (!queryWhenFn())\n      return Promise.resolve({ data: [] as AnyData[] } as Paginated<AnyData>)\n\n    setupPendingState()\n    requestCount.value++\n\n    try {\n      const response = await service.find(___params as any)\n\n      // Keep the two most-recent queries\n      if (response.total) {\n        const queryInfo = store.getQueryInfo(paramsWithPagination.value)\n        const extendedQueryInfo = getExtendedQueryInfo({ queryInfo, service, store, qid })\n        if (extendedQueryInfo)\n          queries.value.push(extendedQueryInfo as unknown as ExtendedQueryInfo)\n        if (queries.value.length > 2)\n          queries.value.shift()\n      }\n      haveLoaded.value = true\n\n      return response\n    }\n    catch (err: any) {\n      error.value = err\n      throw err\n    }\n    finally {\n      isPending.value = false\n    }\n  }\n  const findDebounced = useDebounceFn<any>(find, debounce)\n\n  /** Query Gatekeeping */\n  const makeRequest = async (p?: Params<Query>) => {\n    // If params are null, do nothing\n    if (params.value === null)\n      return\n\n    // If we already have data for the currentQuery, update the cachedParams immediately\n    if (currentQuery.value)\n      updateCachedParams()\n\n    // if the query passes queryWhen, setup the state before the debounce timer starts.\n    if (queryWhenFn())\n      setupPendingState()\n\n    request.value = findDebounced(p)\n    await request.value\n\n    // cache the params to update the computed `data``\n    updateCachedParams()\n  }\n\n  /** Pagination Data */\n  const total = computed(() => {\n    if (['server', 'hybrid'].includes(paginateOn)) {\n      const whichQuery = currentQuery.value || cachedQuery.value\n      return whichQuery?.total || 0\n    }\n    else {\n      const count = service.countInStore(paramsWithoutPagination.value)\n      return count.value\n    }\n  })\n  const pageData = usePageData({ limit, skip, total, request })\n  const { pageCount, currentPage, canPrev, canNext, toStart, toEnd, toPage, next, prev } = pageData\n\n  /** Query Watching */\n  if (['server', 'hybrid'].includes(paginateOn) && _watch) {\n    watch(\n      paramsWithPagination,\n      () => {\n        makeRequest()\n      },\n      { immediate: false, flush: 'sync' },\n    )\n\n    if (immediate)\n      makeRequest()\n  }\n\n  if (paginateOn === 'server' && service.on) {\n    // watch realtime events and re-query\n    // TODO: only re-query when relevant\n    service.on('created', () => {\n      makeRequest()\n    })\n    service.on('patched', () => {\n      makeRequest()\n    })\n\n    // if the current list had an item removed, re-query.\n    service.on('removed', () => {\n      // const id = item[service.store.idField]\n      // const currentIds = data.value.map((i: any) => i[service.store.idField])\n      // if (currentIds.includes(id))\n      makeRequest()\n    })\n  }\n\n  const toReturn = reactive({\n    paramsWithPagination,\n    isSsr: computed(() => {\n      // hack: read total early during SSR to prevent hydration mismatch\n      setTimeout(() => {\n        ref(total.value)\n      }, 0)\n      return store.isSsr\n    }), // ComputedRef<boolean>\n    qid, // WritableComputedRef<string>\n\n    // Data\n    data, // ComputedRef<M[]>\n    allLocalData, // ComputedRef<M[]>\n    total, // ComputedRef<number>\n    limit, // Ref<number>\n    skip, // Ref<number>\n\n    // Queries\n    currentQuery, // ComputedRef<CurrentQuery<M> | null>\n    cachedQuery, // ComputedRef<CurrentQuery<M> | null>\n    latestQuery, // ComputedRef<QueryInfo | null>\n    previousQuery, // ComputedRef<QueryInfo | null>\n\n    // Requests & Watching\n    find: makeRequest, // FindFn<M>\n    request, // Ref<Promise<Paginated<M>>>\n    requestCount, // Ref<number>\n    queryWhen, // (queryWhenFn: () => boolean) => void\n\n    // Request State\n    isPending: computed(() => isPending.value), // ComputedRef<boolean>\n    haveBeenRequested: computed(() => haveBeenRequested.value), // ComputedRef<boolean>\n    haveLoaded: computed(() => haveLoaded.value), // ComputedRef<boolean>\n    error: computed(() => error.value), // ComputedRef<any>\n    clearError, // () => void\n\n    // Pagination Utils\n    pageCount, // Ref<number>\n    currentPage, // Ref<number>\n    canPrev, // ComputedRef<boolean>\n    canNext, // ComputedRef<boolean>\n    next, // () => Promise<void>\n    prev, // () => Promise<void>\n    toStart, // () => Promise<void>\n    toEnd, // () => Promise<void>\n    toPage, // (page: number) => Promise<void>\n  })\n\n  return toReturn\n}\n","import type { Id } from '@feathersjs/feathers'\nimport type { ComputedRef } from 'vue-demi'\nimport type { MaybeRef } from '@vueuse/core'\nimport { computed, isRef, reactive, ref, unref, watch } from 'vue-demi'\nimport type { AnyData } from '../types.js'\nimport type { UseFindGetDeps, UseGetParams } from './types.js'\n\ntype MaybeComputed<M> = ComputedRef<M> | MaybeRef<M>\n\nexport function useGet<M = AnyData>(_id: MaybeComputed<Id | null>,\n  _params: MaybeRef<UseGetParams> = ref({}),\n  deps: UseFindGetDeps) {\n  const { service } = deps\n\n  // normalize args into refs\n  const id = isRef(_id) ? _id : ref(_id)\n  const params = isRef(_params) ? _params : ref(_params)\n\n  /** ID & PARAMS **/\n  const { immediate = true, watch: _watch = true } = params.value\n  const isSsr = computed<boolean>(() => service.store.isSsr)\n\n  /** REQUEST STATE **/\n  const isPending = ref(false)\n  const hasBeenRequested = ref(false)\n  const error = ref<any>(null)\n  const clearError = () => (error.value = null)\n\n  /** STORE ITEMS **/\n  const ids = ref<Id[]>([])\n  const mostRecentId = computed(() => {\n    return ids.value.length && ids.value[ids.value.length - 1]\n  })\n  const data = computed<M | null>(() => {\n    if (isPending.value && mostRecentId.value != null) {\n      const result = service.store.getFromStore(mostRecentId.value, params).value\n      return result\n    }\n    const result = service.store.getFromStore(id.value, params).value\n    return result\n  })\n  const getFromStore = service.store.getFromStore\n\n  const hasLoaded = computed(() => !!data.value)\n\n  /** QUERY WHEN **/\n  let queryWhenFn = () => true\n  const queryWhen = (_queryWhenFn: () => boolean) => {\n    queryWhenFn = _queryWhenFn\n  }\n\n  /** SERVER FETCHING **/\n  const requestCount = ref(0)\n  const request = ref<Promise<AnyData> | null>(null)\n  async function get() {\n    const _id = unref(id)\n    const _params = unref(params)\n\n    if (!queryWhenFn())\n      return\n\n    if (_id == null)\n      return null\n\n    requestCount.value++\n    hasBeenRequested.value = true // never resets\n    isPending.value = true\n    error.value = null\n\n    try {\n      const response = await service.get(_id, _params)\n\n      // Keep a list of retrieved ids\n      if (response && _id)\n        ids.value.push(_id)\n\n      return response\n    }\n    catch (err: any) {\n      error.value = err\n    }\n    finally {\n      isPending.value = false\n    }\n  }\n\n  async function makeRequest() {\n    request.value = get()\n    const val = await request.value\n    return val\n  }\n\n  // Watch the id\n  if (_watch) {\n    watch(\n      id,\n      async () => {\n        await makeRequest()\n      },\n      { immediate },\n    )\n  }\n\n  return reactive({\n    params, // Ref<GetClassParams>\n    isSsr, // ComputedRef<boolean>\n\n    // Data\n    data, // ComputedRef<M | null>\n    ids, // Ref<Id[]>\n    getFromStore, // (id: Id | null, params: Params<Query>) => M | undefined\n\n    // Requests & Watching\n    get: makeRequest, // GetFn<M>\n    request, // Ref<Promise<M | undefined>>\n    requestCount, // Ref<number>\n    queryWhen, // (queryWhenFn: () => boolean) => void\n\n    // Request State\n    isPending: computed(() => isPending.value), // ComputedRef<boolean>\n    hasBeenRequested: computed(() => hasBeenRequested.value), // ComputedRef<boolean>\n    hasLoaded: computed(() => hasLoaded.value), // ComputedRef<boolean>\n    error: computed(() => error.value), // ComputedRef<any>\n    clearError, // () => void\n  })\n}\n","import type { Params as FeathersParams, FeathersService, Id, Paginated, PaginationOptions } from '@feathersjs/feathers'\nimport type { MaybeRef } from '@vueuse/core'\nimport type { ComputedRef } from 'vue-demi'\nimport { computed, isRef, reactive, ref, unref } from 'vue-demi'\nimport type { UseFindOptions, UseFindParams, UseGetParams } from './use-find-get/index.js'\nimport type { AnyData, Params, Query } from './types.js'\nimport { existingServiceMethods, getParams } from './utils/index.js'\nimport { useFind, useGet } from './use-find-get/index.js'\nimport { convertData } from './utils/convert-data'\nimport type { ServiceInstance } from './modeling/index.js'\n\ninterface PiniaServiceOptions {\n  servicePath: string\n  store: any\n}\n\n// FIXME: Those are very hacky, there should be a simpler way of recovering service types\ntype SvcResult<S extends FeathersService> = S extends { get: (...args: any[]) => Promise<infer T> } ? T : never\ntype SvcParams<S extends FeathersService> = (S extends { find: (params: infer T) => any } ? T : never) & Params<Query>\ntype SvcData<S extends FeathersService> = S extends { create: (data: (infer T)[]) => any } ? T : never\ntype SvcPatchData<S extends FeathersService> = S extends { patch: (id: any, data: infer T) => any } ? T : never\n\ntype SvcModel<S extends FeathersService> = ServiceInstance<SvcResult<S>>\n\nexport class PiniaService<Svc extends FeathersService> {\n  store\n  servicePath = ''\n\n  constructor(public service: Svc, public options: PiniaServiceOptions) {\n    this.store = options.store\n    this.servicePath = options.servicePath\n\n    // copy custom methods from service onto this instance, exclude existing methods\n    const keysToIgnore = Object.getOwnPropertyNames(Object.getPrototypeOf(this)).concat(existingServiceMethods)\n    for (const key in service) {\n      if (typeof service[key] === 'function' && !keysToIgnore.includes(key)) {\n        const instance = this as any\n        instance[key] = (service[key] as any).bind(service)\n      }\n    }\n  }\n\n  /**\n   * Prepare new \"instances\" outside of store\n   *\n   * Functionally upgrades plain data to a service model \"instance\".\n   * - flags each record with `__isSetup` to avoid duplicate work.\n   */\n  new(data: Partial<SvcResult<Svc>> = {}): SvcModel<Svc> {\n    const asInstance = this.store.new(data)\n    return reactive(asInstance)\n  }\n\n  /* service methods clone params */\n\n  /**\n   * finds records from the API server by query. Each record is reactive. Lists are non reactive.\n   * For reactive lists, use `findInStore`.\n   */\n  async find(params?: MaybeRef<SvcParams<Svc> & { paginate?: PaginationOptions }>): Promise<Paginated<SvcModel<Svc>>>\n  async find(params?: MaybeRef<SvcParams<Svc> & { paginate: false }>): Promise<SvcModel<Svc>[]>\n  async find(params?: MaybeRef<SvcParams<Svc>>): Promise<Paginated<SvcModel<Svc>> | SvcModel<Svc>[]>\n  async find(params?: MaybeRef<SvcParams<Svc>>): Promise<Paginated<SvcModel<Svc>> | SvcModel<Svc>[]>\n  async find(_params?: MaybeRef<Params<Query>>) {\n    const params = getParams(_params)\n    const result = await this.service.find(params as FeathersParams)\n    return result\n  }\n\n  /**\n   * finds a single record from the API server by query. The record is reactive.\n   */\n  async findOne(params?: MaybeRef<SvcParams<Svc>>): Promise<SvcModel<Svc>>\n  async findOne(_params?: MaybeRef<Params<Query>>) {\n    const params = getParams(_params)\n    params.query = params.query || {}\n    params.query.$limit = 1\n    const result = await this.service.find(params as FeathersParams)\n    const item = (result.data || result)[0] || null\n    return item\n  }\n\n  /**\n   * count records on the API server by query. Returns the number of matching records.\n   */\n  async count(params?: MaybeRef<SvcParams<Svc>>): Promise<Paginated<never>>\n  async count(_params?: MaybeRef<Params<Query>>) {\n    const params = getParams(_params)\n    params.query = params.query || {}\n    params.query.$limit = 0\n    const result = await this.service.find(params as FeathersParams)\n    return result\n  }\n\n  /**\n   * retrieve a record from the API server by id. The record is reactive.\n   */\n  async get(id: Id, params?: MaybeRef<SvcParams<Svc>>): Promise<SvcModel<Svc>>\n  async get(id: Id, _params?: MaybeRef<Params<Query>>) {\n    const params = getParams(_params)\n    const result = await this.service.get(id, params)\n    return result\n  }\n\n  /**\n   * create a record on the API server.\n   */\n  async create(data: SvcData<Svc>): Promise<SvcModel<Svc>>\n  async create(data: AnyData) {\n    const result = await this.service.create(data)\n    return result\n  }\n\n  /**\n   * patch a record on the API server.\n   */\n  async patch(id: Id, data: SvcPatchData<Svc>, params?: MaybeRef<SvcParams<Svc>>): Promise<SvcModel<Svc>>\n  async patch(id: null, data: SvcPatchData<Svc>, params: MaybeRef<SvcParams<Svc>>): Promise<SvcModel<Svc>[]>\n  async patch(id: Id | null, data: AnyData, _params?: MaybeRef<Params<Query>>) {\n    const params = getParams(_params)\n    const result = await this.service.patch(id, data, params)\n    return result\n  }\n\n  /**\n   * remove a record from the API server.\n   */\n  async remove(id: MaybeRef<Id>, params?: MaybeRef<SvcParams<Svc>>): Promise<SvcModel<Svc>>\n  async remove(id: MaybeRef<null>, params: MaybeRef<SvcParams<Svc>>): Promise<SvcModel<Svc>[]>\n  async remove(id: MaybeRef<Id | null>, _params?: MaybeRef<Params<Query>>) {\n    const params = getParams(_params)\n    const result = await this.service.remove(unref(id), params)\n    return result\n  }\n\n  /* store methods accept refs and don't copy params */\n\n  /**\n   * find records in the local store. The returned list and records are reactive.\n   */\n  findInStore(params?: MaybeRef<SvcParams<Svc> & { paginate?: PaginationOptions }>): Paginated<SvcModel<Svc>>\n  findInStore(params?: MaybeRef<SvcParams<Svc> & { paginate: false }>): SvcModel<Svc>[]\n  findInStore(params?: MaybeRef<SvcParams<Svc>>): Paginated<SvcModel<Svc>> | SvcModel<Svc>[]\n  findInStore(params?: MaybeRef<SvcParams<Svc>>): Paginated<SvcModel<Svc>> | SvcModel<Svc>[]\n  findInStore(params?: MaybeRef<Params<Query>>) {\n    const result = this.store.findInStore(params)\n    return reactive({\n      ...result,\n      data: computed(() => {\n        return result.data.map((i: any) => convertData(this, i))\n      }),\n    })\n  }\n\n  /**\n   * find a single record in the local store by query.\n   */\n  findOneInStore(params?: MaybeRef<SvcParams<Svc>>): SvcModel<Svc>\n  findOneInStore(params?: MaybeRef<Params<Query>>) {\n    const result = this.store.findOneInStore(params)\n    return result\n  }\n\n  /**\n   * count records matching a query in the store.\n   */\n  countInStore(params?: MaybeRef<SvcParams<Svc>>): Paginated<never>\n  countInStore(params?: MaybeRef<Params<Query>>) {\n    const result = this.store.countInStore(params)\n    return result\n  }\n\n  /**\n   * get a single record from the store by id\n   */\n  getFromStore(id: MaybeRef<undefined | null>, params: MaybeRef<SvcParams<Svc>>): ComputedRef<SvcModel<Svc>>\n  getFromStore(id: MaybeRef<Id>, params?: MaybeRef<SvcParams<Svc>>): ComputedRef<SvcModel<Svc>>\n  getFromStore(id: MaybeRef<Id | undefined | null>, params?: MaybeRef<Params<Query>>): ComputedRef<SvcModel<Svc>> {\n    const result = this.store.getFromStore(id, params)\n    return result\n  }\n\n  /**\n   * creates or adds an item to the store.\n   */\n  createInStore(data: SvcData<Svc>): SvcModel<Svc>\n  createInStore(data: AnyData) {\n    const result = this.store.createInStore(data)\n    return result\n  }\n\n  /**\n   * patches an item in the store\n   */\n  patchInStore(id: MaybeRef<Id | SvcResult<Svc>>, data: SvcPatchData<Svc>, params?: MaybeRef<SvcParams<Svc>>): SvcModel<Svc>\n  patchInStore(id: MaybeRef<null | SvcResult<Svc>[]>, data: SvcPatchData<Svc>, params: MaybeRef<SvcPatchData<Svc>>): SvcModel<Svc>[]\n  patchInStore(\n    idOrData: MaybeRef<SvcResult<Svc> | SvcResult<Svc>[] | Id | null>,\n    data: MaybeRef<AnyData> = {},\n    params: MaybeRef<AnyData> = {},\n  ) {\n    const result = this.store.patchInStore(idOrData, data, params)\n    return result\n  }\n\n  /**\n   * removes one or more items from the store.\n   */\n  removeFromStore(id: Id, params?: MaybeRef<SvcParams<Svc>>): SvcModel<Svc>\n  removeFromStore(id: undefined | null, params: MaybeRef<SvcParams<Svc>>): SvcModel<Svc>[]\n  removeFromStore(id?: Id | null, params?: MaybeRef<Params<Query>>) {\n    const item = id != null ? this.getFromStore(id).value : null\n    if (item) {\n      const result = this.store.removeFromStore(item)\n      return result\n    }\n    else if (id == null && unref(params)?.query) {\n      const result = this.store.removeByQuery(params)\n      return result\n    }\n  }\n\n  /* hybrid methods */\n\n  useFind(params: ComputedRef<UseFindParams | null>, options?: UseFindOptions) {\n    const _params = isRef(params) ? params : ref(params)\n    return useFind<SvcModel<Svc>>(_params as ComputedRef<UseFindParams | null>, options, { service: this })\n  }\n\n  useGet(id: MaybeRef<Id | null>, params: MaybeRef<UseGetParams> = ref({})) {\n    const _id = isRef(id) ? id : ref(id)\n    const _params = isRef(params) ? params : ref(params)\n    return useGet<SvcModel<Svc>>(_id, _params, { service: this })\n  }\n\n  useGetOnce(_id: MaybeRef<Id | null>, params: MaybeRef<UseGetParams> = {}) {\n    const _params = isRef(params) ? params : ref(params)\n    Object.assign(_params.value, { immediate: false })\n    const results = this.useGet(_id, _params)\n    results.queryWhen(() => !results.data)\n    results.get()\n    return results\n  }\n\n  /* events */\n\n  on(eventName: string | symbol, listener: (...args: any[]) => void) {\n    return this.service.on(eventName, listener)\n  }\n\n  emit(eventName: string | symbol, ...args: any[]): boolean {\n    return this.service.emit(eventName, ...args)\n  }\n\n  removeListener(eventName: string | symbol, listener: (...args: any[]) => void) {\n    return this.service.removeListener(eventName, listener)\n  }\n}\n","/*!\n * isomorphic-mongo-objectid - v@version@\n * Pure JavaScript implementation of mongodb ObjectId for the browser and server\n * https://github.com/john-doherty/isomorphic-mongo-objectid\n * @author John Doherty <www.johndoherty.info>\n * @license MIT\n */\n(function () {\n\n    'use strict';\n\n    /*\n     * Refactored version of source by Jonathan Hberle (jonathan.haeberle@gmail.com)\n     * https://github.com/dreampulse/ObjectId.js\n     */\n\n    var _increment = 0;\n    var _pid = Math.floor(Math.random() * (32767));\n    var _machine = Math.floor(Math.random() * (16777216));\n\n    if (typeof window !== 'undefined') {\n\n        var storage = window.localStorage;\n\n        var mongoMachineId = parseInt(storage.mongoMachineId, 10);\n\n        if (mongoMachineId >= 0 && mongoMachineId <= 16777215) {\n            _machine = Math.floor(storage.mongoMachineId);\n        }\n\n        storage.mongoMachineId = _machine;\n    }\n\n    /**\n     * Creates a new mongo db style ObjectID\n     * @returns {ObjectID} instance of ObjectID\n     */\n    function ObjectID() {\n\n        var args = arguments;\n\n        if (!(this instanceof ObjectID)) {\n            if (args.length > 0) {\n                return new ObjectID(args[0], args[1], args[2], args[3]);\n            }\n            else {\n                return new ObjectID();\n            }\n        }\n\n        if (typeof args[0] === 'object') {\n            this.timestamp = args[0].timestamp;\n            this.machine = args[0].machine;\n            this.pid = args[0].pid;\n            this.increment = args[0].increment;\n        }\n        else if (typeof args[0] === 'string' && args[0].length === 24) {\n            this.timestamp = Number('0x' + args[0].substr(0, 8));\n            this.machine = Number('0x' + args[0].substr(8, 6));\n            this.pid = Number('0x' + args[0].substr(14, 4));\n            this.increment = Number('0x' + args[0].substr(18, 6));\n        }\n        else if (args.length === 4 && args[0] !== null) {\n            this.timestamp = args[0];\n            this.machine = args[1];\n            this.pid = args[2];\n            this.increment = args[3];\n        }\n        else {\n            this.timestamp = Math.floor(new Date().valueOf() / 1000);\n            this.machine = _machine;\n            this.pid = _pid;\n            this.increment = _increment++;\n            if (_increment > 0xffffff) {\n                _increment = 0;\n            }\n        }\n    }\n\n    ObjectID.prototype.getDate = function () {\n        return new Date(this.timestamp * 1000);\n    };\n\n    ObjectID.prototype.toArray = function () {\n        var strOid = this.toString();\n        var array = [];\n        var i;\n        for (i = 0; i < 12; i++) {\n            array[i] = parseInt(strOid.slice(i * 2, i * 2 + 2), 16);\n        }\n        return array;\n    };\n\n    ObjectID.prototype.toString = function () {\n\n        var timestamp = this.timestamp.toString(16);\n        var machine = this.machine.toString(16);\n        var pid = this.pid.toString(16);\n        var increment = this.increment.toString(16);\n\n        return [\n            '00000000'.substr(0, 8 - timestamp.length) + timestamp,\n            '000000'.substr(0, 6 - machine.length) + machine,\n            '0000'.substr(0, 4 - pid.length) + pid,\n            '000000'.substr(0, 6 - increment.length) + increment\n        ].join('');\n    };\n\n    if (typeof module !== 'undefined') {\n        module.exports = ObjectID;\n    }\n    else {\n        window.ObjectID = ObjectID;\n    }\n\n})();\n","module.exports = require('./src/isomorphic-mongo-objectid.js');\n","import ObjectID from 'isomorphic-mongo-objectid'\nimport type { CloneOptions } from '../stores/index.js'\nimport type { AnyData, ById, Params } from '../types.js'\nimport { defineValues } from '../utils/define-properties'\nimport type { BaseModelData, ModelInstanceData, StoreInstanceProps } from './types.js'\n\ninterface UseModelInstanceOptions<M, Q extends AnyData> {\n  idField: string\n  clonesById: ById<AnyData>\n  clone: (item: M, data?: Record<string, any>, options?: CloneOptions) => M\n  commit: (item: M, data?: Partial<M>) => M\n  reset: (item: M, data?: Record<string, any>) => M\n  createInStore: (data: M | M[]) => M | M[]\n  removeFromStore: (data: M | M[] | null, params?: Params<Q>) => M | M[] | null\n}\n\nexport function useModelInstance<M extends AnyData, Q extends AnyData>(data: ModelInstanceData<M>,\n  options: UseModelInstanceOptions<M, Q>) {\n  if (data.__isStoreInstance)\n    return data\n\n  const { idField, clonesById, clone, commit, reset, createInStore, removeFromStore } = options\n  const __isClone = data.__isClone || false\n\n  // instance.__isTemp\n  Object.defineProperty(data, '__isTemp', {\n    configurable: true,\n    enumerable: false,\n    get() {\n      return this[this.__idField] == null\n    },\n  })\n\n  // BaseModel properties\n  const asBaseModel = defineValues(data, {\n    __isStoreInstance: true,\n    __isClone,\n    __idField: idField,\n    __tempId: data[idField] == null && data.__tempId == null ? new ObjectID().toString() : data.__tempId || undefined,\n    hasClone(this: M) {\n      const id = this[this.__idField] || this.__tempId\n      const item = clonesById[id]\n      return item || null\n    },\n    clone(this: M, data: Partial<M> = {}, options: CloneOptions = {}) {\n      const item = clone(this, data, options)\n      return item\n    },\n    commit(this: M, data: Partial<M> = {}) {\n      const item = commit(this, data)\n      return item\n    },\n    reset(this: M, data: Partial<M> = {}) {\n      const item = reset(this, data)\n      return item\n    },\n    createInStore(this: M) {\n      const item = createInStore(this)\n      return item\n    },\n    removeFromStore(this: M) {\n      const item = removeFromStore(this)\n      return item\n    },\n  }) as M & BaseModelData & StoreInstanceProps<M>\n\n  return asBaseModel\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\n\nvar typeChecker = function (type) {\n    var typeString = \"[object \" + type + \"]\";\n    return function (value) {\n        return getClassName(value) === typeString;\n    };\n};\nvar getClassName = function (value) { return Object.prototype.toString.call(value); };\nvar comparable = function (value) {\n    if (value instanceof Date) {\n        return value.getTime();\n    }\n    else if (isArray(value)) {\n        return value.map(comparable);\n    }\n    else if (value && typeof value.toJSON === \"function\") {\n        return value.toJSON();\n    }\n    return value;\n};\nvar coercePotentiallyNull = function (value) {\n    return value == null ? null : value;\n};\nvar isArray = typeChecker(\"Array\");\nvar isObject = typeChecker(\"Object\");\nvar isFunction = typeChecker(\"Function\");\nvar isVanillaObject = function (value) {\n    return (value &&\n        (value.constructor === Object ||\n            value.constructor === Array ||\n            value.constructor.toString() === \"function Object() { [native code] }\" ||\n            value.constructor.toString() === \"function Array() { [native code] }\") &&\n        !value.toJSON);\n};\nvar equals = function (a, b) {\n    if (a == null && a == b) {\n        return true;\n    }\n    if (a === b) {\n        return true;\n    }\n    if (Object.prototype.toString.call(a) !== Object.prototype.toString.call(b)) {\n        return false;\n    }\n    if (isArray(a)) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (var i = 0, length_1 = a.length; i < length_1; i++) {\n            if (!equals(a[i], b[i]))\n                return false;\n        }\n        return true;\n    }\n    else if (isObject(a)) {\n        if (Object.keys(a).length !== Object.keys(b).length) {\n            return false;\n        }\n        for (var key in a) {\n            if (!equals(a[key], b[key]))\n                return false;\n        }\n        return true;\n    }\n    return false;\n};\n\n/**\n * Walks through each value given the context - used for nested operations. E.g:\n * { \"person.address\": { $eq: \"blarg\" }}\n */\nvar walkKeyPathValues = function (item, keyPath, next, depth, key, owner) {\n    var currentKey = keyPath[depth];\n    // if array, then try matching. Might fall through for cases like:\n    // { $eq: [1, 2, 3] }, [ 1, 2, 3 ].\n    if (isArray(item) && isNaN(Number(currentKey))) {\n        for (var i = 0, length_1 = item.length; i < length_1; i++) {\n            // if FALSE is returned, then terminate walker. For operations, this simply\n            // means that the search critera was met.\n            if (!walkKeyPathValues(item[i], keyPath, next, depth, i, item)) {\n                return false;\n            }\n        }\n    }\n    if (depth === keyPath.length || item == null) {\n        return next(item, key, owner, depth === 0);\n    }\n    return walkKeyPathValues(item[currentKey], keyPath, next, depth + 1, currentKey, item);\n};\nvar BaseOperation = /** @class */ (function () {\n    function BaseOperation(params, owneryQuery, options, name) {\n        this.params = params;\n        this.owneryQuery = owneryQuery;\n        this.options = options;\n        this.name = name;\n        this.init();\n    }\n    BaseOperation.prototype.init = function () { };\n    BaseOperation.prototype.reset = function () {\n        this.done = false;\n        this.keep = false;\n    };\n    return BaseOperation;\n}());\nvar GroupOperation = /** @class */ (function (_super) {\n    __extends(GroupOperation, _super);\n    function GroupOperation(params, owneryQuery, options, children) {\n        var _this = _super.call(this, params, owneryQuery, options) || this;\n        _this.children = children;\n        return _this;\n    }\n    /**\n     */\n    GroupOperation.prototype.reset = function () {\n        this.keep = false;\n        this.done = false;\n        for (var i = 0, length_2 = this.children.length; i < length_2; i++) {\n            this.children[i].reset();\n        }\n    };\n    /**\n     */\n    GroupOperation.prototype.childrenNext = function (item, key, owner, root) {\n        var done = true;\n        var keep = true;\n        for (var i = 0, length_3 = this.children.length; i < length_3; i++) {\n            var childOperation = this.children[i];\n            if (!childOperation.done) {\n                childOperation.next(item, key, owner, root);\n            }\n            if (!childOperation.keep) {\n                keep = false;\n            }\n            if (childOperation.done) {\n                if (!childOperation.keep) {\n                    break;\n                }\n            }\n            else {\n                done = false;\n            }\n        }\n        this.done = done;\n        this.keep = keep;\n    };\n    return GroupOperation;\n}(BaseOperation));\nvar NamedGroupOperation = /** @class */ (function (_super) {\n    __extends(NamedGroupOperation, _super);\n    function NamedGroupOperation(params, owneryQuery, options, children, name) {\n        var _this = _super.call(this, params, owneryQuery, options, children) || this;\n        _this.name = name;\n        return _this;\n    }\n    return NamedGroupOperation;\n}(GroupOperation));\nvar QueryOperation = /** @class */ (function (_super) {\n    __extends(QueryOperation, _super);\n    function QueryOperation() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.propop = true;\n        return _this;\n    }\n    /**\n     */\n    QueryOperation.prototype.next = function (item, key, parent, root) {\n        this.childrenNext(item, key, parent, root);\n    };\n    return QueryOperation;\n}(GroupOperation));\nvar NestedOperation = /** @class */ (function (_super) {\n    __extends(NestedOperation, _super);\n    function NestedOperation(keyPath, params, owneryQuery, options, children) {\n        var _this = _super.call(this, params, owneryQuery, options, children) || this;\n        _this.keyPath = keyPath;\n        _this.propop = true;\n        /**\n         */\n        _this._nextNestedValue = function (value, key, owner, root) {\n            _this.childrenNext(value, key, owner, root);\n            return !_this.done;\n        };\n        return _this;\n    }\n    /**\n     */\n    NestedOperation.prototype.next = function (item, key, parent) {\n        walkKeyPathValues(item, this.keyPath, this._nextNestedValue, 0, key, parent);\n    };\n    return NestedOperation;\n}(GroupOperation));\nvar createTester = function (a, compare) {\n    if (a instanceof Function) {\n        return a;\n    }\n    if (a instanceof RegExp) {\n        return function (b) {\n            var result = typeof b === \"string\" && a.test(b);\n            a.lastIndex = 0;\n            return result;\n        };\n    }\n    var comparableA = comparable(a);\n    return function (b) { return compare(comparableA, comparable(b)); };\n};\nvar EqualsOperation = /** @class */ (function (_super) {\n    __extends(EqualsOperation, _super);\n    function EqualsOperation() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.propop = true;\n        return _this;\n    }\n    EqualsOperation.prototype.init = function () {\n        this._test = createTester(this.params, this.options.compare);\n    };\n    EqualsOperation.prototype.next = function (item, key, parent) {\n        if (!Array.isArray(parent) || parent.hasOwnProperty(key)) {\n            if (this._test(item, key, parent)) {\n                this.done = true;\n                this.keep = true;\n            }\n        }\n    };\n    return EqualsOperation;\n}(BaseOperation));\nvar createEqualsOperation = function (params, owneryQuery, options) { return new EqualsOperation(params, owneryQuery, options); };\nvar numericalOperationCreator = function (createNumericalOperation) { return function (params, owneryQuery, options, name) {\n    return createNumericalOperation(params, owneryQuery, options, name);\n}; };\nvar numericalOperation = function (createTester) {\n    return numericalOperationCreator(function (params, owneryQuery, options, name) {\n        var typeofParams = typeof comparable(params);\n        var test = createTester(params);\n        return new EqualsOperation(function (b) {\n            var actualValue = coercePotentiallyNull(b);\n            return (typeof comparable(actualValue) === typeofParams && test(actualValue));\n        }, owneryQuery, options, name);\n    });\n};\nvar createNamedOperation = function (name, params, parentQuery, options) {\n    var operationCreator = options.operations[name];\n    if (!operationCreator) {\n        throwUnsupportedOperation(name);\n    }\n    return operationCreator(params, parentQuery, options, name);\n};\nvar throwUnsupportedOperation = function (name) {\n    throw new Error(\"Unsupported operation: \" + name);\n};\nvar containsOperation = function (query, options) {\n    for (var key in query) {\n        if (options.operations.hasOwnProperty(key) || key.charAt(0) === \"$\")\n            return true;\n    }\n    return false;\n};\nvar createNestedOperation = function (keyPath, nestedQuery, parentKey, owneryQuery, options) {\n    if (containsOperation(nestedQuery, options)) {\n        var _a = createQueryOperations(nestedQuery, parentKey, options), selfOperations = _a[0], nestedOperations = _a[1];\n        if (nestedOperations.length) {\n            throw new Error(\"Property queries must contain only operations, or exact objects.\");\n        }\n        return new NestedOperation(keyPath, nestedQuery, owneryQuery, options, selfOperations);\n    }\n    return new NestedOperation(keyPath, nestedQuery, owneryQuery, options, [\n        new EqualsOperation(nestedQuery, owneryQuery, options)\n    ]);\n};\nvar createQueryOperation = function (query, owneryQuery, _a) {\n    if (owneryQuery === void 0) { owneryQuery = null; }\n    var _b = _a === void 0 ? {} : _a, compare = _b.compare, operations = _b.operations;\n    var options = {\n        compare: compare || equals,\n        operations: Object.assign({}, operations || {})\n    };\n    var _c = createQueryOperations(query, null, options), selfOperations = _c[0], nestedOperations = _c[1];\n    var ops = [];\n    if (selfOperations.length) {\n        ops.push(new NestedOperation([], query, owneryQuery, options, selfOperations));\n    }\n    ops.push.apply(ops, nestedOperations);\n    if (ops.length === 1) {\n        return ops[0];\n    }\n    return new QueryOperation(query, owneryQuery, options, ops);\n};\nvar createQueryOperations = function (query, parentKey, options) {\n    var selfOperations = [];\n    var nestedOperations = [];\n    if (!isVanillaObject(query)) {\n        selfOperations.push(new EqualsOperation(query, query, options));\n        return [selfOperations, nestedOperations];\n    }\n    for (var key in query) {\n        if (options.operations.hasOwnProperty(key)) {\n            var op = createNamedOperation(key, query[key], query, options);\n            if (op) {\n                if (!op.propop && parentKey && !options.operations[parentKey]) {\n                    throw new Error(\"Malformed query. \" + key + \" cannot be matched against property.\");\n                }\n            }\n            // probably just a flag for another operation (like $options)\n            if (op != null) {\n                selfOperations.push(op);\n            }\n        }\n        else if (key.charAt(0) === \"$\") {\n            throwUnsupportedOperation(key);\n        }\n        else {\n            nestedOperations.push(createNestedOperation(key.split(\".\"), query[key], key, query, options));\n        }\n    }\n    return [selfOperations, nestedOperations];\n};\nvar createOperationTester = function (operation) { return function (item, key, owner) {\n    operation.reset();\n    operation.next(item, key, owner);\n    return operation.keep;\n}; };\nvar createQueryTester = function (query, options) {\n    if (options === void 0) { options = {}; }\n    return createOperationTester(createQueryOperation(query, null, options));\n};\n\nvar $Ne = /** @class */ (function (_super) {\n    __extends($Ne, _super);\n    function $Ne() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.propop = true;\n        return _this;\n    }\n    $Ne.prototype.init = function () {\n        this._test = createTester(this.params, this.options.compare);\n    };\n    $Ne.prototype.reset = function () {\n        _super.prototype.reset.call(this);\n        this.keep = true;\n    };\n    $Ne.prototype.next = function (item) {\n        if (this._test(item)) {\n            this.done = true;\n            this.keep = false;\n        }\n    };\n    return $Ne;\n}(BaseOperation));\n// https://docs.mongodb.com/manual/reference/operator/query/elemMatch/\nvar $ElemMatch = /** @class */ (function (_super) {\n    __extends($ElemMatch, _super);\n    function $ElemMatch() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.propop = true;\n        return _this;\n    }\n    $ElemMatch.prototype.init = function () {\n        if (!this.params || typeof this.params !== \"object\") {\n            throw new Error(\"Malformed query. $elemMatch must by an object.\");\n        }\n        this._queryOperation = createQueryOperation(this.params, this.owneryQuery, this.options);\n    };\n    $ElemMatch.prototype.reset = function () {\n        _super.prototype.reset.call(this);\n        this._queryOperation.reset();\n    };\n    $ElemMatch.prototype.next = function (item) {\n        if (isArray(item)) {\n            for (var i = 0, length_1 = item.length; i < length_1; i++) {\n                // reset query operation since item being tested needs to pass _all_ query\n                // operations for it to be a success\n                this._queryOperation.reset();\n                var child = item[i];\n                this._queryOperation.next(child, i, item, false);\n                this.keep = this.keep || this._queryOperation.keep;\n            }\n            this.done = true;\n        }\n        else {\n            this.done = false;\n            this.keep = false;\n        }\n    };\n    return $ElemMatch;\n}(BaseOperation));\nvar $Not = /** @class */ (function (_super) {\n    __extends($Not, _super);\n    function $Not() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.propop = true;\n        return _this;\n    }\n    $Not.prototype.init = function () {\n        this._queryOperation = createQueryOperation(this.params, this.owneryQuery, this.options);\n    };\n    $Not.prototype.reset = function () {\n        _super.prototype.reset.call(this);\n        this._queryOperation.reset();\n    };\n    $Not.prototype.next = function (item, key, owner, root) {\n        this._queryOperation.next(item, key, owner, root);\n        this.done = this._queryOperation.done;\n        this.keep = !this._queryOperation.keep;\n    };\n    return $Not;\n}(BaseOperation));\nvar $Size = /** @class */ (function (_super) {\n    __extends($Size, _super);\n    function $Size() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.propop = true;\n        return _this;\n    }\n    $Size.prototype.init = function () { };\n    $Size.prototype.next = function (item) {\n        if (isArray(item) && item.length === this.params) {\n            this.done = true;\n            this.keep = true;\n        }\n        // if (parent && parent.length === this.params) {\n        //   this.done = true;\n        //   this.keep = true;\n        // }\n    };\n    return $Size;\n}(BaseOperation));\nvar assertGroupNotEmpty = function (values) {\n    if (values.length === 0) {\n        throw new Error(\"$and/$or/$nor must be a nonempty array\");\n    }\n};\nvar $Or = /** @class */ (function (_super) {\n    __extends($Or, _super);\n    function $Or() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.propop = false;\n        return _this;\n    }\n    $Or.prototype.init = function () {\n        var _this = this;\n        assertGroupNotEmpty(this.params);\n        this._ops = this.params.map(function (op) {\n            return createQueryOperation(op, null, _this.options);\n        });\n    };\n    $Or.prototype.reset = function () {\n        this.done = false;\n        this.keep = false;\n        for (var i = 0, length_2 = this._ops.length; i < length_2; i++) {\n            this._ops[i].reset();\n        }\n    };\n    $Or.prototype.next = function (item, key, owner) {\n        var done = false;\n        var success = false;\n        for (var i = 0, length_3 = this._ops.length; i < length_3; i++) {\n            var op = this._ops[i];\n            op.next(item, key, owner);\n            if (op.keep) {\n                done = true;\n                success = op.keep;\n                break;\n            }\n        }\n        this.keep = success;\n        this.done = done;\n    };\n    return $Or;\n}(BaseOperation));\nvar $Nor = /** @class */ (function (_super) {\n    __extends($Nor, _super);\n    function $Nor() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.propop = false;\n        return _this;\n    }\n    $Nor.prototype.next = function (item, key, owner) {\n        _super.prototype.next.call(this, item, key, owner);\n        this.keep = !this.keep;\n    };\n    return $Nor;\n}($Or));\nvar $In = /** @class */ (function (_super) {\n    __extends($In, _super);\n    function $In() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.propop = true;\n        return _this;\n    }\n    $In.prototype.init = function () {\n        var _this = this;\n        this._testers = this.params.map(function (value) {\n            if (containsOperation(value, _this.options)) {\n                throw new Error(\"cannot nest $ under \" + _this.name.toLowerCase());\n            }\n            return createTester(value, _this.options.compare);\n        });\n    };\n    $In.prototype.next = function (item, key, owner) {\n        var done = false;\n        var success = false;\n        for (var i = 0, length_4 = this._testers.length; i < length_4; i++) {\n            var test = this._testers[i];\n            if (test(item)) {\n                done = true;\n                success = true;\n                break;\n            }\n        }\n        this.keep = success;\n        this.done = done;\n    };\n    return $In;\n}(BaseOperation));\nvar $Nin = /** @class */ (function (_super) {\n    __extends($Nin, _super);\n    function $Nin(params, ownerQuery, options, name) {\n        var _this = _super.call(this, params, ownerQuery, options, name) || this;\n        _this.propop = true;\n        _this._in = new $In(params, ownerQuery, options, name);\n        return _this;\n    }\n    $Nin.prototype.next = function (item, key, owner, root) {\n        this._in.next(item, key, owner);\n        if (isArray(owner) && !root) {\n            if (this._in.keep) {\n                this.keep = false;\n                this.done = true;\n            }\n            else if (key == owner.length - 1) {\n                this.keep = true;\n                this.done = true;\n            }\n        }\n        else {\n            this.keep = !this._in.keep;\n            this.done = true;\n        }\n    };\n    $Nin.prototype.reset = function () {\n        _super.prototype.reset.call(this);\n        this._in.reset();\n    };\n    return $Nin;\n}(BaseOperation));\nvar $Exists = /** @class */ (function (_super) {\n    __extends($Exists, _super);\n    function $Exists() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.propop = true;\n        return _this;\n    }\n    $Exists.prototype.next = function (item, key, owner) {\n        if (owner.hasOwnProperty(key) === this.params) {\n            this.done = true;\n            this.keep = true;\n        }\n    };\n    return $Exists;\n}(BaseOperation));\nvar $And = /** @class */ (function (_super) {\n    __extends($And, _super);\n    function $And(params, owneryQuery, options, name) {\n        var _this = _super.call(this, params, owneryQuery, options, params.map(function (query) { return createQueryOperation(query, owneryQuery, options); }), name) || this;\n        _this.propop = false;\n        assertGroupNotEmpty(params);\n        return _this;\n    }\n    $And.prototype.next = function (item, key, owner, root) {\n        this.childrenNext(item, key, owner, root);\n    };\n    return $And;\n}(NamedGroupOperation));\nvar $All = /** @class */ (function (_super) {\n    __extends($All, _super);\n    function $All(params, owneryQuery, options, name) {\n        var _this = _super.call(this, params, owneryQuery, options, params.map(function (query) { return createQueryOperation(query, owneryQuery, options); }), name) || this;\n        _this.propop = true;\n        return _this;\n    }\n    $All.prototype.next = function (item, key, owner, root) {\n        this.childrenNext(item, key, owner, root);\n    };\n    return $All;\n}(NamedGroupOperation));\nvar $eq = function (params, owneryQuery, options) {\n    return new EqualsOperation(params, owneryQuery, options);\n};\nvar $ne = function (params, owneryQuery, options, name) { return new $Ne(params, owneryQuery, options, name); };\nvar $or = function (params, owneryQuery, options, name) { return new $Or(params, owneryQuery, options, name); };\nvar $nor = function (params, owneryQuery, options, name) { return new $Nor(params, owneryQuery, options, name); };\nvar $elemMatch = function (params, owneryQuery, options, name) { return new $ElemMatch(params, owneryQuery, options, name); };\nvar $nin = function (params, owneryQuery, options, name) { return new $Nin(params, owneryQuery, options, name); };\nvar $in = function (params, owneryQuery, options, name) {\n    return new $In(params, owneryQuery, options, name);\n};\nvar $lt = numericalOperation(function (params) { return function (b) {\n    return b != null && b < params;\n}; });\nvar $lte = numericalOperation(function (params) { return function (b) {\n    return b === params || b <= params;\n}; });\nvar $gt = numericalOperation(function (params) { return function (b) {\n    return b != null && b > params;\n}; });\nvar $gte = numericalOperation(function (params) { return function (b) {\n    return b === params || b >= params;\n}; });\nvar $mod = function (_a, owneryQuery, options) {\n    var mod = _a[0], equalsValue = _a[1];\n    return new EqualsOperation(function (b) { return comparable(b) % mod === equalsValue; }, owneryQuery, options);\n};\nvar $exists = function (params, owneryQuery, options, name) { return new $Exists(params, owneryQuery, options, name); };\nvar $regex = function (pattern, owneryQuery, options) {\n    return new EqualsOperation(new RegExp(pattern, owneryQuery.$options), owneryQuery, options);\n};\nvar $not = function (params, owneryQuery, options, name) { return new $Not(params, owneryQuery, options, name); };\nvar typeAliases = {\n    number: function (v) { return typeof v === \"number\"; },\n    string: function (v) { return typeof v === \"string\"; },\n    bool: function (v) { return typeof v === \"boolean\"; },\n    array: function (v) { return Array.isArray(v); },\n    null: function (v) { return v === null; },\n    timestamp: function (v) { return v instanceof Date; }\n};\nvar $type = function (clazz, owneryQuery, options) {\n    return new EqualsOperation(function (b) {\n        if (typeof clazz === \"string\") {\n            if (!typeAliases[clazz]) {\n                throw new Error(\"Type alias does not exist\");\n            }\n            return typeAliases[clazz](b);\n        }\n        return b != null ? b instanceof clazz || b.constructor === clazz : false;\n    }, owneryQuery, options);\n};\nvar $and = function (params, ownerQuery, options, name) { return new $And(params, ownerQuery, options, name); };\nvar $all = function (params, ownerQuery, options, name) { return new $All(params, ownerQuery, options, name); };\nvar $size = function (params, ownerQuery, options) { return new $Size(params, ownerQuery, options, \"$size\"); };\nvar $options = function () { return null; };\nvar $where = function (params, ownerQuery, options) {\n    var test;\n    if (isFunction(params)) {\n        test = params;\n    }\n    else if (!process.env.CSP_ENABLED) {\n        test = new Function(\"obj\", \"return \" + params);\n    }\n    else {\n        throw new Error(\"In CSP mode, sift does not support strings in \\\"$where\\\" condition\");\n    }\n    return new EqualsOperation(function (b) { return test.bind(b)(b); }, ownerQuery, options);\n};\n\nvar defaultOperations = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    $Size: $Size,\n    $eq: $eq,\n    $ne: $ne,\n    $or: $or,\n    $nor: $nor,\n    $elemMatch: $elemMatch,\n    $nin: $nin,\n    $in: $in,\n    $lt: $lt,\n    $lte: $lte,\n    $gt: $gt,\n    $gte: $gte,\n    $mod: $mod,\n    $exists: $exists,\n    $regex: $regex,\n    $not: $not,\n    $type: $type,\n    $and: $and,\n    $all: $all,\n    $size: $size,\n    $options: $options,\n    $where: $where\n});\n\nvar createDefaultQueryOperation = function (query, ownerQuery, _a) {\n    var _b = _a === void 0 ? {} : _a, compare = _b.compare, operations = _b.operations;\n    return createQueryOperation(query, ownerQuery, {\n        compare: compare,\n        operations: Object.assign({}, defaultOperations, operations || {})\n    });\n};\nvar createDefaultQueryTester = function (query, options) {\n    if (options === void 0) { options = {}; }\n    var op = createDefaultQueryOperation(query, null, options);\n    return createOperationTester(op);\n};\n\nexport { $Size, $all, $and, $elemMatch, $eq, $exists, $gt, $gte, $in, $lt, $lte, $mod, $ne, $nin, $nor, $not, $options, $or, $regex, $size, $type, $where, EqualsOperation, createDefaultQueryOperation, createEqualsOperation, createOperationTester, createQueryOperation, createQueryTester, createDefaultQueryTester as default };\n//# sourceMappingURL=index.js.map\n","import { createEqualsOperation } from 'sift'\n\n// Simulate SQL's case-sensitive LIKE.\n// A combination of answers from https://stackoverflow.com/questions/1314045/emulating-sql-like-in-javascript\nexport function like(value: string, search: string, regexOptions = 'g') {\n  const specials = ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\\\']\n  // Remove specials\n  search = search.replace(new RegExp(`(\\\\${specials.join('|\\\\')})`, regexOptions), '\\\\$1')\n  // Replace % and _ with equivalent regex\n  search = search.replace(/%/g, '.*').replace(/_/g, '.')\n  // Check matches\n  return RegExp(`^${search}$`, regexOptions).test(value)\n}\n\n// Simulate PostgreSQL's case-insensitive ILIKE\nexport function iLike(str: string, search: string) {\n  return like(str, search, 'ig')\n}\n\nexport function $like(params: any, ownerQuery: any, options: any) {\n  return createEqualsOperation((value: any) => like(value, params), ownerQuery, options)\n}\n\nexport function $notLike(params: any, ownerQuery: any, options: any) {\n  return createEqualsOperation((value: any) => !like(value, params), ownerQuery, options)\n}\n\nexport function $ilike(params: any, ownerQuery: any, options: any) {\n  return createEqualsOperation((value: any) => iLike(value, params), ownerQuery, options)\n}\n\nfunction $notILike(params: any, ownerQuery: any, options: any) {\n  return createEqualsOperation((value: any) => !iLike(value, params), ownerQuery, options)\n}\n\nexport const sqlOperations = {\n  $like,\n  $notLike,\n  $notlike: $notLike,\n  $ilike,\n  $iLike: $ilike,\n  $notILike,\n}\n","import type { MaybeRef } from '@vueuse/core'\nimport type { Id } from '@feathersjs/feathers'\nimport { _ } from '@feathersjs/commons'\nimport { computed, reactive, unref } from 'vue-demi'\nimport { filterQuery, select, sorter } from '@feathersjs/adapter-commons'\nimport sift from 'sift'\nimport fastCopy from 'fast-copy'\nimport type { AnyData, Params } from '../types.js'\nimport { deepUnref, getArray } from '../utils/index.js'\nimport { sqlOperations } from './utils-custom-operators.js'\nimport type { StorageMapUtils } from './storage.js'\n\ninterface UseServiceLocalOptions<M extends AnyData> {\n  idField: string\n  itemStorage: StorageMapUtils<M>\n  tempStorage?: StorageMapUtils<M>\n  cloneStorage?: StorageMapUtils<M>\n  addItemToStorage: any\n  whitelist?: string[]\n  paramsForServer?: string[]\n  customSiftOperators?: Record<string, any>\n}\n\nconst FILTERS = ['$sort', '$limit', '$skip', '$select']\nconst additionalOperators = [\n  '$in',\n  '$nin',\n  '$exists',\n  'eq',\n  'ne',\n  '$mod',\n  '$all',\n  '$not',\n  '$size',\n  '$type',\n  '$regex',\n  '$options',\n  '$where',\n  '$elemMatch',\n]\n\nexport function useServiceLocal<M extends AnyData, Q extends AnyData>(options: UseServiceLocalOptions<M>) {\n  const {\n    idField,\n    itemStorage,\n    tempStorage,\n    cloneStorage,\n    addItemToStorage,\n    paramsForServer = [],\n    whitelist = [],\n    customSiftOperators = {},\n  } = options\n\n  const operations = Object.assign({}, sqlOperations, customSiftOperators)\n\n  /** @private */\n  const _filterQueryOperators = computed(() => {\n    return additionalOperators.concat(whitelist || []).concat(Object.keys(operations))\n  })\n\n  const filterItems = (params: Params<Q>, startingValues: M[] = []) => {\n    params = { ...unref(params) } || {}\n    const _paramsForServer = paramsForServer\n    const q = _.omit(params.query || {}, ..._paramsForServer)\n\n    const { query, filters } = filterQuery(q, {\n      operators: _filterQueryOperators.value,\n    })\n    let values = startingValues.concat(itemStorage.list.value)\n\n    if (tempStorage && params.temps)\n      values.push(...tempStorage.list.value)\n\n    if (filters.$or)\n      query.$or = filters.$or\n\n    if (filters.$and)\n      query.$and = filters.$and\n\n    values = values.filter(sift(query, { operations }))\n    return { values, filters }\n  }\n\n  function findInStore(_params: MaybeRef<Params<Q>>) {\n    const result = computed(() => {\n      const params = unref(_params)\n      // clean up any nested refs\n      if (params.query)\n        params.query = deepUnref(params.query)\n\n      const filtered = filterItems(params)\n      const filters = filtered.filters\n      let values = filtered.values\n\n      const total = values.length\n\n      if (filters.$sort)\n        values.sort(sorter(filters.$sort))\n\n      if (filters.$skip)\n        values = values.slice(filters.$skip)\n\n      if (typeof filters.$limit !== 'undefined')\n        values = values.slice(0, filters.$limit)\n\n      return {\n        total,\n        limit: filters.$limit || 0,\n        skip: filters.$skip || 0,\n        data: params.clones\n          ? values.map((v: any) => (v.clone ? v.clone(undefined, { useExisting: true }) : v))\n          : values,\n      }\n    })\n    return reactive({\n      total: computed(() => result.value.total),\n      limit: computed(() => result.value.limit),\n      skip: computed(() => result.value.skip),\n      data: computed(() => result.value.data),\n    })\n  }\n\n  function findOneInStore(params: MaybeRef<Params<Q>>) {\n    const result = findInStore(params)\n    const item = computed(() => {\n      return result.data[0] || null\n    })\n    return item\n  }\n\n  function countInStore(params: MaybeRef<Params<Q>>) {\n    const value = computed(() => {\n      params = { ...unref(params) }\n\n      if (!params.query)\n        throw new Error('params must contain a query object')\n\n      params.query = _.omit(params.query, ...FILTERS)\n      return findInStore(params).total\n    })\n    return value\n  }\n\n  const getFromStore = (_id: MaybeRef<Id | null>, params?: Params<Q>) => {\n    return computed((): M | null => {\n      const id = unref(_id)\n      params = fastCopy(unref(params) || {})\n      if (params.query)\n        params.query = deepUnref(params.query)\n\n      let item = null\n      const existingItem = itemStorage.getItem(id as Id) && select(params, idField)(itemStorage.getItem(id as Id))\n      const tempItem\n        = tempStorage && tempStorage.getItem(id as Id) && select(params, '__tempId')(tempStorage.getItem(id as Id))\n\n      if (existingItem)\n        item = existingItem\n      else if (tempItem)\n        item = tempItem\n\n      const toReturn = params.clones && item.clone ? item.clone(undefined, { useExisting: true }) : item || null\n      return toReturn\n    })\n  }\n\n  /**\n   * Write records to the store.\n   * @param data a single record or array of records.\n   * @returns data added or modified in the store. If you pass an array, you get an array back.\n   */\n  function createInStore<N = MaybeRef<M | M[]>>(data: N): N {\n    const { items, isArray } = getArray(unref(data))\n\n    const _items = items.map((item: N) => {\n      const stored = addItemToStorage(unref(item))\n      return stored\n    })\n\n    return isArray ? _items : _items[0]\n  }\n\n  // TODO\n  function patchInStore(\n    _idOrData: MaybeRef<M | M[] | Id | null>,\n    _data: MaybeRef<AnyData> = {},\n    _params: MaybeRef<Params<Q>> = {},\n  ) {\n    const idOrData = unref(_idOrData)\n    const data = unref(_data)\n    const params = unref(_params)\n\n    // patches provided items using the `data` from the closure scope.\n    function updateItems(items: any[]) {\n      const patched = items\n        .map((item: M | Id | null) => {\n          item = unref(item)\n          // convert ids to items from the store\n          if (typeof item === 'number' || typeof item === 'string')\n            item = getFromStore(item as Id).value\n\n          if (item == null)\n            return null\n\n          const toWrite = { ...item, ...data }\n          const stored = addItemToStorage(toWrite)\n          return stored\n        })\n        .filter(i => i)\n      return patched\n    }\n\n    if (idOrData === null) {\n      // patching multiple cannot use an empty array\n      if (params?.query && !Object.keys(params?.query).length) {\n        throw new Error(\n          'cannot perform multiple patchInStore with an empty query. You must explicitly provide a query. To patch all items, try using a query that matches all items, like \"{ id: { $exists: true } }\"',\n        )\n      }\n      // patch by query\n      const fromStore = findInStore(params).data\n      const items = updateItems(fromStore)\n\n      return items\n    }\n    else {\n      // patch provided data\n      const { items, isArray } = getArray(idOrData)\n      const patchedItems = updateItems(items)\n\n      return isArray ? patchedItems : patchedItems[0]\n    }\n  }\n\n  /**\n   * If a clone is provided, it removes the clone from the store.\n   * If a temp is provided, it removes the temp from the store.\n   * If an item is provided, the item and its associated temp and clone are removed.\n   * If a string is provided, it removes any item, temp, or clone from the stores.\n   * @param data\n   */\n  function removeFromStore(data: M | M[] | null, params?: Params<Q>) {\n    if (data === null && params?.query && Object.keys(params?.query).length) {\n      const clones = cloneStorage ? cloneStorage.list.value : []\n      const { values } = filterItems(params, clones)\n      const result = removeItems(values)\n      return result\n    }\n    else if (data !== null) {\n      removeItems(data)\n    }\n\n    return data\n  }\n\n  function removeItems(data: M | M[]) {\n    const { items } = getArray(data)\n    items.forEach((item: M) => {\n      if (typeof item === 'string') {\n        itemStorage.removeItem(item)\n        tempStorage?.removeItem(item)\n        cloneStorage?.removeItem(item)\n      }\n      else {\n        if ((item as M).__isClone)\n          return cloneStorage?.remove(item as M)\n\n        if ((item as M).__isTemp)\n          return tempStorage?.remove(item as M)\n\n        itemStorage.remove(item)\n        tempStorage?.remove(item)\n        cloneStorage?.remove(item)\n      }\n    })\n    return data\n  }\n\n  return {\n    findInStore,\n    findOneInStore,\n    countInStore,\n    getFromStore,\n    createInStore,\n    patchInStore,\n    removeFromStore,\n  }\n}\n","import type { Id } from '@feathersjs/feathers'\nimport { computed, reactive, del as vueDel, set as vueSet } from 'vue-demi'\nimport type { AnyData, ById } from '../types.js'\nimport type { AssignFn, beforeWriteFn, onReadFn } from './types.js'\n\ninterface UseServiceStorageOptions<M extends AnyData> {\n  getId: (item: M) => string\n  onRead?: onReadFn<M>\n  beforeWrite?: beforeWriteFn<M>\n  assign?: AssignFn<M>\n}\n\nexport type StorageMapUtils<M extends AnyData> = ReturnType<typeof useServiceStorage<M>>\n\n/**\n * General storage adapter\n */\nexport function useServiceStorage<M extends AnyData>({\n  getId,\n  onRead = item => item,\n  beforeWrite = item => item,\n  assign = (dest, src) => Object.assign(dest, src),\n}: UseServiceStorageOptions<M>) {\n  const byId: ById<M> = reactive({})\n\n  const list = computed(() => {\n    return Object.values(byId)\n  })\n\n  const ids = computed(() => {\n    return Object.keys(byId)\n  })\n\n  /**\n   * Checks if an item with the provided `id` is stored.\n   * @param id\n   * @returns\n   */\n  const hasItem = (id: Id) => {\n    return !!byId[id]\n  }\n\n  /**\n   * Checks if the provided `item` is stored.\n   * @param item\n   * @returns boolean\n   */\n  const has = (item: M) => {\n    const id = getId(item)\n    return hasItem(id as Id)\n  }\n\n  /**\n   * Retrives the stored record that matches the provided `id`.\n   * @param id\n   * @returns\n   */\n  const getItem = (id: Id) => {\n    const inStore = byId[id]\n    const _item = inStore ? onRead(inStore) : null\n    return _item as M\n  }\n\n  const setItem = (id: Id, item: M) => {\n    if (id == null)\n      throw new Error('item has no id')\n    vueSet(byId, id, beforeWrite(item))\n    return getItem(id)\n  }\n\n  /**\n   * Writes the provided item to the store\n   * @param item item to store\n   * @returns\n   */\n  const set = (item: M) => {\n    const id = getId(item) as Id\n    return setItem(id, item)\n  }\n\n  /**\n   * If the item is stored, merges the `item` into the stored version.\n   * If not yet stored, the item is stored.\n   * @param item the item to merge or write to the store.\n   * @returns the stored item\n   */\n  const merge = (item: M) => {\n    const id = getId(item) as Id\n    const existing = getItem(id)\n    if (existing)\n      assign(existing, item)\n    else setItem(id, item)\n\n    return getItem(id)\n  }\n\n  /**\n   * Retrieves the stored record that matches the provided `item`.\n   * @param item\n   * @returns\n   */\n  const get = (item: M) => {\n    const id = getId(item) as Id\n    return getItem(id)\n  }\n\n  /**\n   * Remove item with matching `id`, if found.\n   * @param id\n   * @returns boolean indicating if an item was removed\n   */\n  const removeItem = (id: Id) => {\n    const hadItem = hasItem(id)\n    if (hadItem)\n      vueDel(byId, id)\n\n    return hadItem\n  }\n\n  /**\n   * remove `item` if found\n   * @param item\n   * @returns boolean indicating if item was removed\n   */\n  const remove = (item: M) => {\n    const id = getId(item) as Id\n    return removeItem(id)\n  }\n\n  const getKeys = () => {\n    return ids.value\n  }\n\n  /**\n   * empties the store\n   */\n  const clear = () => {\n    Object.keys(byId).forEach((id) => {\n      vueDel(byId, id)\n    })\n  }\n\n  return { byId, list, ids, getId, clear, has, hasItem, get, getItem, set, setItem, remove, removeItem, getKeys, merge }\n}\n","import type { AnyData } from '../types.js'\nimport type { beforeWriteFn, onReadFn } from './types.js'\nimport type { StorageMapUtils } from './storage.js'\nimport { useServiceStorage } from './storage.js'\n\ninterface UseServiceTempsOptions<M extends AnyData> {\n  getId: (item: M) => string\n  itemStorage: StorageMapUtils<M>\n  onRead?: onReadFn<M>\n  beforeWrite?: beforeWriteFn<M>\n}\n\nexport function useServiceTemps<M extends AnyData>(options: UseServiceTempsOptions<M>) {\n  const { getId, itemStorage, onRead, beforeWrite } = options\n\n  const tempStorage = useServiceStorage<M>({\n    getId,\n    onRead,\n    beforeWrite,\n  })\n\n  function moveTempToItems(data: M) {\n    if (tempStorage.has(data))\n      tempStorage.remove(data)\n\n    return itemStorage.set(data)\n  }\n\n  return { tempStorage, moveTempToItems }\n}\n","import { del as vueDelete } from 'vue-demi'\nimport fastCopy from 'fast-copy'\nimport type { AnyData, MakeCopyOptions } from '../types.js'\nimport type { CloneOptions, beforeWriteFn, onReadFn } from './types.js'\nimport type { StorageMapUtils } from './storage.js'\nimport { useServiceStorage } from './storage.js'\n\nexport interface UseServiceClonesOptions<M extends AnyData> {\n  itemStorage: StorageMapUtils<M>\n  tempStorage: StorageMapUtils<M>\n  onRead?: onReadFn<M>\n  beforeWrite?: beforeWriteFn<M>\n  makeCopy?: (item: M, data: AnyData, { isClone }: MakeCopyOptions) => M\n}\n\nexport function useServiceClones<M extends AnyData>(options: UseServiceClonesOptions<M>) {\n  const { itemStorage, tempStorage, onRead, beforeWrite } = options\n  const defaultMakeCopy = (item: M, data: AnyData = {}, { isClone }: MakeCopyOptions) => {\n    return fastCopy(Object.assign({}, item, data, { __isClone: isClone }))\n  }\n  const makeCopy = options.makeCopy || defaultMakeCopy\n\n  const cloneStorage = useServiceStorage({\n    getId: (item) => {\n      const id = itemStorage.getId(item as M)\n      return id != null ? id : tempStorage.getId(item)\n    },\n    onRead,\n    beforeWrite,\n  })\n\n  /**\n   * Makes sure the provided item is stored in itemStorage or tempStorage.\n   * Private\n   */\n  function assureOriginalIsStored(item: M): M {\n    // Make sure the stored version is always up to date with the latest instance data. (the instance used to call instance.clone)\n    if (!item.__isClone) {\n      if (itemStorage.has(item))\n        itemStorage.merge(item)\n      else if (tempStorage.has(item))\n        tempStorage.merge(item)\n    }\n    const existingItem = itemStorage.get(item) || tempStorage.get(item)\n    if (!existingItem) {\n      if (itemStorage.getId(item) != null)\n        itemStorage.merge(item)\n      else if (tempStorage.getId(item) != null)\n        tempStorage.merge(item)\n    }\n    return itemStorage.get(item) || tempStorage.get(item)\n  }\n\n  /**\n   * Fast-copies the provided `item`, placing it in `cloneStorage`.\n   * @param item the object to clone.\n   * @param data an object to be merged before storing in cloneStorage.\n   * @param options.useExisting {Boolean} allows using the existing clone instead of re-cloning.\n   * @returns\n   */\n  function clone(item: M, data = {}, options: CloneOptions = {}): M {\n    const existingClone = cloneStorage.get(item)\n\n    assureOriginalIsStored(item)\n\n    if (existingClone && options.useExisting) {\n      return existingClone as M\n    }\n    else {\n      const clone = reset(item, data)\n      return clone as M\n    }\n  }\n\n  /**\n   * If the `item` has an id, it's merged or written to the itemStore.\n   * If the `item` does not have an id, it's merged or written to the tempStore.\n   * @param item\n   * @param data\n   * @returns stored item or stored temp\n   */\n  function commit(item: M, data: Partial<M> = {}) {\n    const itemId = itemStorage.getId(item)\n    const _item = makeCopy(item, data, { isClone: false })\n    // copyAssociations(clone, newOriginal, clone.getModel().associations)\n    if (itemId) {\n      itemStorage.merge(_item)\n      return itemStorage.get(_item)\n    }\n    else {\n      tempStorage.merge(_item)\n      return tempStorage.get(_item)\n    }\n  }\n\n  /**\n   * If a clone exists, resets the clone to match the item or temp\n   * If a clone does not exist, writes the item as the clone.\n   * @param item\n   * @param data\n   * @returns\n   */\n  function reset(item: M, data = {}): M {\n    const original = assureOriginalIsStored(item)\n    const existingClone = cloneStorage.get(item)\n\n    if (existingClone) {\n      const copied = makeCopy(original, data, { isClone: true })\n      Object.keys(original).forEach((key) => {\n        if (original[key] == null)\n          vueDelete(copied, key)\n      })\n      cloneStorage.merge(copied)\n    }\n    else {\n      const copied = makeCopy(item, data, { isClone: true })\n      cloneStorage.set(copied)\n    }\n    return cloneStorage.get(item)\n  }\n\n  function markAsClone(item: M) {\n    Object.defineProperty(item, '__isClone', {\n      writable: false,\n      enumerable: false,\n      value: true,\n    })\n    return item\n  }\n\n  return {\n    cloneStorage,\n    clone,\n    commit,\n    reset,\n    markAsClone,\n  }\n}\n","import fastCopy from 'fast-copy'\nimport type { AnyData, MakeCopyOptions } from '../types.js'\nimport { defineValues } from '../utils/index.js'\nimport { useServiceTemps } from './temps.js'\nimport { useServiceClones } from './clones.js'\nimport { useServiceStorage } from './storage.js'\n\ninterface UseAllStorageOptions {\n  getIdField: (val: AnyData) => any\n  setupInstance: any\n}\n\nexport function useAllStorageTypes<M extends AnyData>(options: UseAllStorageOptions) {\n  const { getIdField, setupInstance } = options\n\n  /**\n   * Makes a copy of the Model instance with __isClone properly set\n   * Private\n   */\n  const makeCopy = (item: M, data: AnyData = {}, { isClone }: MakeCopyOptions) => {\n    const copied = fastCopy(item)\n    Object.assign(copied, data)\n    // instance.__isTemp\n    Object.defineProperty(copied, '__isTemp', {\n      configurable: true,\n      enumerable: false,\n      get() {\n        return this[this.__idField] == null\n      },\n    })\n    const withExtras = defineValues(copied, {\n      __isClone: isClone,\n      __tempId: item.__tempId,\n    })\n    return withExtras\n  }\n\n  // item storage\n  const itemStorage = useServiceStorage<M>({\n    getId: getIdField,\n    beforeWrite: setupInstance,\n    onRead: setupInstance,\n  })\n\n  // temp item storage\n  const { tempStorage, moveTempToItems } = useServiceTemps<M>({\n    getId: item => item.__tempId,\n    itemStorage,\n    beforeWrite: setupInstance,\n    onRead: setupInstance,\n  })\n\n  // clones\n  const { cloneStorage, clone, commit, reset, markAsClone } = useServiceClones<M>({\n    itemStorage,\n    tempStorage,\n    makeCopy,\n    beforeWrite: (item) => {\n      markAsClone(item)\n      return setupInstance(item)\n    },\n    onRead: setupInstance,\n  })\n\n  /**\n   * Stores the provided item in the correct storage (itemStorage, tempStorage, or cloneStorage).\n   * If an item has both an id and a tempId, it gets moved from tempStorage to itemStorage.\n   * Private\n   */\n  const addItemToStorage = (item: M) => {\n    const id = getIdField(item)\n    item = setupInstance(item)\n\n    if (item.__isClone)\n      return cloneStorage.merge(item)\n    else if (id != null && item.__tempId != null)\n      return moveTempToItems(item)\n    else if (id != null)\n      return itemStorage.merge(item)\n    else if (tempStorage && item.__tempId != null)\n      return tempStorage?.merge(item)\n\n    return itemStorage.merge(item)\n  }\n\n  return {\n    itemStorage,\n    tempStorage,\n    cloneStorage,\n    clone,\n    commit,\n    reset,\n    addItemToStorage,\n  }\n}\n","import type { Query } from '@feathersjs/feathers'\n\nimport { computed, unref } from 'vue-demi'\nimport type { MaybeRef } from '@vueuse/core'\nimport type { AnyData } from '../types.js'\nimport { useModelInstance } from '../modeling/use-model-instance'\nimport { useServiceLocal } from './local-queries.js'\n\nimport { useAllStorageTypes } from './all-storage-types.js'\n\nexport interface UseDataStoreOptions {\n  idField: string\n  ssr?: MaybeRef<boolean>\n  customSiftOperators?: Record<string, any>\n  setupInstance?: any\n}\n\nfunction makeDefaultOptions() {\n  return {\n    skipGetIfExists: false,\n  }\n}\n\nexport function useDataStore<M extends AnyData, Q extends Query>(_options: UseDataStoreOptions) {\n  const options = Object.assign({}, makeDefaultOptions(), _options)\n  const { idField, customSiftOperators } = options\n\n  // storage\n  const { itemStorage, tempStorage, cloneStorage, clone, commit, reset, addItemToStorage } = useAllStorageTypes<M>({\n    getIdField: (val: AnyData) => val[idField],\n    setupInstance,\n  })\n\n  // local data filtering\n  const { findInStore, findOneInStore, countInStore, getFromStore, createInStore, patchInStore, removeFromStore }\n    = useServiceLocal<M, Q>({\n      idField,\n      itemStorage,\n      tempStorage,\n      cloneStorage,\n      addItemToStorage,\n      customSiftOperators,\n    })\n\n  function setupInstance<N extends M>(this: any, data: N) {\n    const asBaseModel = useModelInstance(data, {\n      idField,\n      clonesById: cloneStorage.byId,\n      clone,\n      commit,\n      reset,\n      createInStore,\n      removeFromStore,\n    })\n\n    if (data.__isSetup) {\n      return asBaseModel\n    }\n    else {\n      const afterSetup = options.setupInstance ? options.setupInstance(asBaseModel) : asBaseModel\n      Object.defineProperty(afterSetup, '__isSetup', { value: true })\n      return afterSetup\n    }\n  }\n\n  const isSsr = computed(() => {\n    const ssr = unref(options.ssr)\n    return !!ssr\n  })\n\n  function clearAll() {\n    itemStorage.clear()\n    tempStorage.clear()\n    cloneStorage.clear()\n  }\n\n  const store = {\n    new: setupInstance,\n    idField,\n    isSsr,\n\n    // items\n    itemsById: itemStorage.byId,\n    items: itemStorage.list,\n    itemIds: itemStorage.ids,\n\n    // temps\n    tempsById: tempStorage.byId,\n    temps: tempStorage.list,\n    tempIds: tempStorage.ids,\n\n    // clones\n    clonesById: cloneStorage.byId,\n    clones: cloneStorage.list,\n    cloneIds: cloneStorage.ids,\n    clone,\n    commit,\n    reset,\n\n    // local queries\n    findInStore,\n    findOneInStore,\n    countInStore,\n    createInStore,\n    getFromStore,\n    patchInStore,\n    removeFromStore,\n    clearAll,\n  }\n\n  return store\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createDebug = exports.setDebug = exports.noopDebug = void 0;\nconst debuggers = {};\nfunction noopDebug() {\n    return function () { };\n}\nexports.noopDebug = noopDebug;\nlet defaultInitializer = noopDebug;\nfunction setDebug(debug) {\n    defaultInitializer = debug;\n    Object.keys(debuggers).forEach((name) => {\n        debuggers[name] = debug(name);\n    });\n}\nexports.setDebug = setDebug;\nfunction createDebug(name) {\n    if (!debuggers[name]) {\n        debuggers[name] = defaultInitializer(name);\n    }\n    return (...args) => debuggers[name](...args);\n}\nexports.createDebug = createDebug;\n//# sourceMappingURL=debug.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createSymbol = exports.isPromise = exports._ = exports.stripSlashes = void 0;\n// Removes all leading and trailing slashes from a path\nfunction stripSlashes(name) {\n    return name.replace(/^(\\/+)|(\\/+)$/g, '');\n}\nexports.stripSlashes = stripSlashes;\n// A set of lodash-y utility functions that use ES6\nexports._ = {\n    each(obj, callback) {\n        if (obj && typeof obj.forEach === 'function') {\n            obj.forEach(callback);\n        }\n        else if (exports._.isObject(obj)) {\n            Object.keys(obj).forEach((key) => callback(obj[key], key));\n        }\n    },\n    some(value, callback) {\n        return Object.keys(value)\n            .map((key) => [value[key], key])\n            .some(([val, key]) => callback(val, key));\n    },\n    every(value, callback) {\n        return Object.keys(value)\n            .map((key) => [value[key], key])\n            .every(([val, key]) => callback(val, key));\n    },\n    keys(obj) {\n        return Object.keys(obj);\n    },\n    values(obj) {\n        return exports._.keys(obj).map((key) => obj[key]);\n    },\n    isMatch(obj, item) {\n        return exports._.keys(item).every((key) => obj[key] === item[key]);\n    },\n    isEmpty(obj) {\n        return exports._.keys(obj).length === 0;\n    },\n    isObject(item) {\n        return typeof item === 'object' && !Array.isArray(item) && item !== null;\n    },\n    isObjectOrArray(value) {\n        return typeof value === 'object' && value !== null;\n    },\n    extend(first, ...rest) {\n        return Object.assign(first, ...rest);\n    },\n    omit(obj, ...keys) {\n        const result = exports._.extend({}, obj);\n        keys.forEach((key) => delete result[key]);\n        return result;\n    },\n    pick(source, ...keys) {\n        return keys.reduce((result, key) => {\n            if (source[key] !== undefined) {\n                result[key] = source[key];\n            }\n            return result;\n        }, {});\n    },\n    // Recursively merge the source object into the target object\n    merge(target, source) {\n        if (exports._.isObject(target) && exports._.isObject(source)) {\n            Object.keys(source).forEach((key) => {\n                if (exports._.isObject(source[key])) {\n                    if (!target[key]) {\n                        Object.assign(target, { [key]: {} });\n                    }\n                    exports._.merge(target[key], source[key]);\n                }\n                else {\n                    Object.assign(target, { [key]: source[key] });\n                }\n            });\n        }\n        return target;\n    }\n};\n// Duck-checks if an object looks like a promise\nfunction isPromise(result) {\n    return exports._.isObject(result) && typeof result.then === 'function';\n}\nexports.isPromise = isPromise;\nfunction createSymbol(name) {\n    return typeof Symbol !== 'undefined' ? Symbol.for(name) : name;\n}\nexports.createSymbol = createSymbol;\n__exportStar(require(\"./debug\"), exports);\n//# sourceMappingURL=index.js.map","import type { ComputedRef, Ref } from 'vue-demi'\nimport { ref, set } from 'vue-demi'\nimport stringify from 'fast-json-stable-stringify'\nimport { _ } from '@feathersjs/commons/lib'\nimport { deepUnref, getId, hasOwn } from '../utils/index.js'\nimport type { Params, Query, QueryInfo } from '../types.js'\nimport type { PaginationState, UpdatePaginationForQueryOptions } from './types.js'\n\nexport interface UseServicePagination {\n  idField: string\n  isSsr: ComputedRef<boolean>\n  defaultLimit?: number\n}\n\nexport function useServicePagination(options: UseServicePagination) {\n  const { idField, isSsr } = options\n  const defaultLimit = options.defaultLimit || 10\n\n  const pagination = ref({}) as Ref<PaginationState>\n\n  function clearPagination() {\n    const { defaultLimit, defaultSkip } = pagination.value\n    pagination.value = { defaultLimit, defaultSkip } as any\n  }\n\n  /**\n   * Stores pagination data on state.pagination based on the query identifier\n   * (qid) The qid must be manually assigned to `params.qid`\n   */\n  function updatePaginationForQuery({\n    qid,\n    response,\n    query = {},\n    preserveSsr = false,\n  }: UpdatePaginationForQueryOptions) {\n    const { data, total } = response\n    const ids = data.map((i: any) => getId(i, idField))\n    const queriedAt = new Date().getTime()\n    const { queryId, queryParams, pageId, pageParams } = getQueryInfo({ qid, query })\n\n    if (!pagination.value[qid])\n      set(pagination.value, qid, {})\n\n    if (!hasOwn(query, '$limit') && hasOwn(response, 'limit'))\n      set(pagination.value, 'defaultLimit', response.limit)\n\n    if (!hasOwn(query, '$skip') && hasOwn(response, 'skip'))\n      set(pagination.value, 'defaultSkip', response.skip)\n\n    const mostRecent = {\n      query,\n      queryId,\n      queryParams,\n      pageId,\n      pageParams,\n      queriedAt,\n      total,\n    }\n\n    const existingPageData = pagination.value[qid]?.[queryId]?.[pageId as string]\n\n    const qidData = pagination.value[qid] || {}\n    Object.assign(qidData, { mostRecent })\n\n    set(qidData, queryId, qidData[queryId] || {})\n    const queryData = {\n      total,\n      queryParams,\n    }\n\n    set(qidData, queryId, Object.assign({}, qidData[queryId], queryData))\n\n    const ssr = preserveSsr ? existingPageData?.ssr : isSsr.value\n\n    const pageData = {\n      [pageId as string]: { pageParams, ids, queriedAt, ssr: !!ssr },\n    }\n\n    Object.assign(qidData[queryId], pageData)\n\n    const newState = Object.assign({}, pagination.value[qid], qidData)\n\n    set(pagination.value, qid, newState)\n  }\n\n  function unflagSsr(params: Params<Query>) {\n    const queryInfo = getQueryInfo(params)\n    const { qid, queryId, pageId } = queryInfo\n\n    const pageData = pagination.value[qid]?.[queryId]?.[pageId as string]\n    pageData.ssr = false\n  }\n\n  function getQueryInfo(_params: Params<Query>): QueryInfo {\n    const params = deepUnref(_params)\n    const { query = {} } = params\n    const qid = params.qid || 'default'\n    const $limit = query?.$limit || defaultLimit\n    const $skip = query?.$skip || 0\n\n    const pageParams = $limit !== undefined ? { $limit, $skip } : undefined\n    const pageId = pageParams ? stringify(pageParams) : undefined\n\n    const queryParams = _.omit(query, '$limit', '$skip')\n    const queryId = stringify(queryParams)\n\n    return {\n      qid,\n      query,\n      queryId,\n      queryParams,\n      pageParams,\n      pageId,\n      isExpired: false,\n    }\n  }\n\n  return {\n    pagination,\n    updatePaginationForQuery,\n    unflagSsr,\n    getQueryInfo,\n    clearPagination,\n  }\n}\n","import type { NullableId } from '@feathersjs/feathers'\nimport type { Ref } from 'vue-demi'\nimport { computed, del, ref, set } from 'vue-demi'\nimport type { RequestTypeById } from './types.js'\n\nfunction defaultPending() {\n  return {\n    find: 0,\n    count: 0,\n    get: 0,\n    create: 0,\n    update: 0,\n    patch: 0,\n    remove: 0,\n  }\n}\n\nexport function useServicePending() {\n  const isPending = ref(defaultPending())\n\n  const createPendingById = ref({}) as Ref<Record<string | number | symbol, true>>\n  const updatePendingById = ref({}) as Ref<Record<string | number | symbol, true>>\n  const patchPendingById = ref({}) as Ref<Record<string | number | symbol, true>>\n  const removePendingById = ref({}) as Ref<Record<string | number | symbol, true>>\n\n  const isFindPending = computed(() => {\n    return isPending.value.find > 0\n  })\n\n  const isCountPending = computed(() => {\n    return isPending.value.count > 0\n  })\n\n  const isGetPending = computed(() => {\n    return isPending.value.get > 0\n  })\n\n  const isCreatePending = computed(() => {\n    return isPending.value.create > 0 || Object.keys(createPendingById.value).length > 0\n  })\n\n  const isUpdatePending = computed(() => {\n    return isPending.value.update > 0 || Object.keys(updatePendingById.value).length > 0\n  })\n\n  const isPatchPending = computed(() => {\n    return isPending.value.patch > 0 || Object.keys(patchPendingById.value).length > 0\n  })\n\n  const isRemovePending = computed(() => {\n    return isPending.value.remove > 0 || Object.keys(removePendingById.value).length > 0\n  })\n\n  function setPending(method: 'find' | 'count' | 'get' | 'create' | 'update' | 'patch' | 'remove', value: boolean) {\n    if (value)\n      isPending.value[method]++\n    else isPending.value[method]--\n  }\n\n  function setPendingById(id: NullableId, method: RequestTypeById, val: boolean) {\n    if (id == null)\n      return\n\n    let place\n\n    if (method === 'create')\n      place = createPendingById.value\n    else if (method === 'update')\n      place = updatePendingById.value\n    else if (method === 'patch')\n      place = patchPendingById.value\n    else if (method === 'remove')\n      place = removePendingById.value\n\n    if (val)\n      set(place, id, true)\n    else del(place, id)\n  }\n\n  function unsetPendingById(...ids: NullableId[]) {\n    ids.forEach((id) => {\n      if (id == null)\n        return\n      del(createPendingById.value, id)\n      del(updatePendingById.value, id)\n      del(patchPendingById.value, id)\n      del(removePendingById.value, id)\n    })\n  }\n\n  function clearAllPending() {\n    isPending.value = defaultPending()\n\n    createPendingById.value = {}\n    updatePendingById.value = {}\n    patchPendingById.value = {}\n    removePendingById.value = {}\n  }\n\n  return {\n    isPending,\n    createPendingById,\n    updatePendingById,\n    patchPendingById,\n    removePendingById,\n    isFindPending,\n    isCountPending,\n    isGetPending,\n    isCreatePending,\n    isUpdatePending,\n    isPatchPending,\n    isRemovePending,\n    setPending,\n    setPendingById,\n    unsetPendingById,\n    clearAllPending,\n  }\n}\n","import type { Id } from '@feathersjs/feathers'\nimport { del, reactive, set } from 'vue-demi'\nimport type { MaybeArray } from '../types.js'\nimport { getArray } from '../utils/index.js'\nimport type { EventLocks, EventName } from './types.js'\n\nexport function useServiceEventLocks() {\n  const eventLocks = reactive<EventLocks>({\n    created: {},\n    patched: {},\n    updated: {},\n    removed: {},\n  })\n\n  function toggleEventLock(data: MaybeArray<Id>, event: EventName) {\n    const { items: ids } = getArray(data)\n    ids.forEach((id) => {\n      const currentLock = eventLocks[event][id]\n      if (currentLock) {\n        clearEventLock(data, event)\n      }\n      else {\n        set(eventLocks[event], id, true)\n        // auto-clear event lock after 250 ms\n        setTimeout(() => {\n          clearEventLock(data, event)\n        }, 250)\n      }\n    })\n  }\n  function clearEventLock(data: MaybeArray<Id>, event: EventName) {\n    const { items: ids } = getArray(data)\n    ids.forEach((id) => {\n      del(eventLocks[event], id)\n    })\n  }\n  return { eventLocks, toggleEventLock, clearEventLock }\n}\n","import { reactive } from 'vue'\nimport type { AnyData } from '../types'\n\nexport function useSsrQueryCache() {\n  const resultsByQid = reactive<Record<string, AnyData>>({})\n\n  function getQid(qid: string) {\n    return resultsByQid[qid]\n  }\n  function setQid(qid: string, data: any) {\n    resultsByQid[qid] = data\n  }\n  function clearQid(qid: string) {\n    delete resultsByQid[qid]\n  }\n  function clearAllQids() {\n    Object.keys(resultsByQid).forEach((qid) => {\n      clearQid(qid)\n    })\n  }\n\n  return { resultsByQid, getQid, setQid, clearQid, clearAllQids }\n}\n","import type { Query } from '@feathersjs/feathers'\n\nimport { computed, unref } from 'vue-demi'\nimport type { MaybeRef } from '@vueuse/core'\nimport type { AnyData } from '../types.js'\nimport { useModelInstance } from '../modeling/use-model-instance'\nimport { useServiceLocal } from './local-queries.js'\n\nimport { useServicePagination } from './pagination.js'\nimport { useServicePending } from './pending.js'\nimport { useServiceEventLocks } from './event-locks.js'\nimport { useAllStorageTypes } from './all-storage-types.js'\nimport { useSsrQueryCache } from './ssr-query-cache.js'\n\nexport interface UseServiceStoreOptions {\n  idField: string\n  servicePath: string\n  defaultLimit?: number\n  whitelist?: string[]\n  paramsForServer?: string[]\n  skipGetIfExists?: boolean\n  ssr?: MaybeRef<boolean>\n  customSiftOperators?: Record<string, any>\n  setupInstance?: any\n}\n\nfunction makeDefaultOptions() {\n  return {\n    skipGetIfExists: false,\n  }\n}\n\nexport function useServiceStore<M extends AnyData, Q extends Query>(_options: UseServiceStoreOptions) {\n  const options = Object.assign({}, makeDefaultOptions(), _options)\n  const { idField, servicePath, whitelist, paramsForServer, defaultLimit, customSiftOperators } = options\n\n  // storage\n  const { itemStorage, tempStorage, cloneStorage, clone, commit, reset, addItemToStorage } = useAllStorageTypes<M>({\n    getIdField: (val: AnyData) => val[idField],\n    setupInstance,\n  })\n\n  // local data filtering\n  const { findInStore, findOneInStore, countInStore, getFromStore, createInStore, patchInStore, removeFromStore }\n    = useServiceLocal<M, Q>({\n      idField,\n      itemStorage,\n      tempStorage,\n      cloneStorage,\n      addItemToStorage,\n      whitelist,\n      paramsForServer,\n      customSiftOperators,\n    })\n\n  function setupInstance<N extends M>(this: any, data: N) {\n    const asBaseModel = useModelInstance(data, {\n      idField,\n      clonesById: cloneStorage.byId,\n      clone,\n      commit,\n      reset,\n      createInStore,\n      removeFromStore,\n    })\n\n    if (data.__isSetup) {\n      return asBaseModel\n    }\n    else {\n      const afterSetup = options.setupInstance ? options.setupInstance(asBaseModel) : asBaseModel\n      Object.defineProperty(afterSetup, '__isSetup', { value: true })\n      return afterSetup\n    }\n  }\n\n  // pending state\n  const pendingState = useServicePending()\n\n  const isSsr = computed(() => {\n    const ssr = unref(options.ssr)\n    return !!ssr\n  })\n\n  // pagination\n  const { pagination, clearPagination, updatePaginationForQuery, getQueryInfo, unflagSsr } = useServicePagination({\n    idField,\n    isSsr,\n    defaultLimit,\n  })\n\n  // ssr qid cache\n  const { resultsByQid, getQid, setQid, clearQid, clearAllQids } = useSsrQueryCache()\n\n  function clearAll() {\n    itemStorage.clear()\n    tempStorage.clear()\n    cloneStorage.clear()\n    clearPagination()\n    pendingState.clearAllPending()\n    clearAllQids()\n  }\n\n  // event locks\n  const eventLocks = useServiceEventLocks()\n\n  const store = {\n    new: setupInstance,\n    idField,\n    servicePath,\n    isSsr,\n    defaultLimit,\n\n    // items\n    itemsById: itemStorage.byId,\n    items: itemStorage.list,\n    itemIds: itemStorage.ids,\n\n    // temps\n    tempsById: tempStorage.byId,\n    temps: tempStorage.list,\n    tempIds: tempStorage.ids,\n\n    // clones\n    clonesById: cloneStorage.byId,\n    clones: cloneStorage.list,\n    cloneIds: cloneStorage.ids,\n    clone,\n    commit,\n    reset,\n\n    // local queries\n    findInStore,\n    findOneInStore,\n    countInStore,\n    createInStore,\n    getFromStore,\n    patchInStore,\n    removeFromStore,\n    clearAll,\n\n    // ssr qid cache\n    resultsByQid,\n    getQid,\n    setQid,\n    clearQid,\n    clearAllQids,\n\n    // server options\n    whitelist,\n    paramsForServer,\n\n    // server pagination\n    pagination,\n    updatePaginationForQuery,\n    unflagSsr,\n    getQueryInfo,\n    ...pendingState,\n    ...eventLocks,\n  }\n\n  return store\n}\n","import { watch } from 'vue-demi'\n\ntype EventName = 'created' | 'updated' | 'patched' | 'removed'\n\ninterface QueuePromiseState {\n  promise: Promise<any>\n  isResolved: boolean\n  getter: 'isCreatePending' | 'isUpdatePending' | 'isPatchPending' | 'isRemovePending'\n}\n\nconst events = ['created', 'updated', 'patched', 'removed']\nconst state: { [key: string]: QueuePromiseState } = {}\n\nexport function makeGetterName(event: EventName) {\n  return `is${event.slice(0, 1).toUpperCase()}${event.slice(1, event.length - 1)}Pending`\n}\n\nexport function makeState(event: EventName) {\n  return {\n    promise: null,\n    isResolved: false,\n    getter: makeGetterName(event),\n  }\n}\nexport function resetState() {\n  events.forEach((e) => {\n    delete state[e]\n  })\n}\n/**\n * Creates or reuses a promise for each event type, like \"created\". The promise\n * resolves when the matching `isPending` attribute, like \"isCreatePending\" becomes\n * false.\n * @param store\n * @param event\n * @returns\n */\nexport function useQueuePromise(store: any, event: EventName) {\n  state[event] = state[event] || makeState(event)\n\n  if (!state[event].promise || state[event].isResolved) {\n    state[event].promise = new Promise((resolve) => {\n      const stopWatching = watch(\n        () => store[state[event].getter],\n        async (isPending) => {\n          if (!isPending) {\n            setTimeout(() => {\n              stopWatching()\n              state[event].isResolved = true\n              resolve(state[event].isResolved)\n            }, 0)\n          }\n        },\n        { immediate: true },\n      )\n    })\n  }\n  return state[event].promise\n}\n","module.exports = debounce;\n\nfunction debounce(fn, delay, atStart, guarantee) {\n  var timeout;\n  var args;\n  var self;\n\n  return function debounced() {\n    self = this;\n    args = Array.prototype.slice.call(arguments);\n\n    if (timeout && (atStart || guarantee)) {\n      return;\n    } else if (!atStart) {\n      clear();\n\n      timeout = setTimeout(run, delay);\n      return timeout;\n    }\n\n    timeout = setTimeout(clear, delay);\n    fn.apply(self, args);\n\n    function run() {\n      clear();\n      fn.apply(self, args);\n    }\n\n    function clear() {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n}\n","import type { FeathersService } from '@feathersjs/feathers'\nimport { del, ref, set } from 'vue-demi'\nimport _debounce from 'just-debounce'\nimport type { AnyData } from '../types.js'\nimport { convertData, getId, hasOwn } from '../utils/index.js'\nimport type { PiniaService } from '../create-pinia-service.js'\nimport type { HandleEvents, HandledEvents } from './types.js'\n\ninterface UseServiceStoreEventsOptions<M extends AnyData> {\n  service: PiniaService<FeathersService<any, any>>\n  debounceEventsTime?: number\n  debounceEventsGuarantee?: boolean\n  handleEvents?: HandleEvents<M>\n}\n\nexport function useServiceEvents<M extends AnyData>(options: UseServiceStoreEventsOptions<M>) {\n  if (!options.service || options.handleEvents === false)\n    return\n\n  const service = options.service\n\n  const addOrUpdateById = ref({})\n  const removeItemsById = ref({})\n\n  const flushAddOrUpdateQueue = _debounce(\n    async () => {\n      const values = Object.values(addOrUpdateById.value)\n      if (values.length === 0)\n        return\n      service.store.createInStore(values)\n      addOrUpdateById.value = {}\n    },\n    options.debounceEventsTime || 20,\n    undefined,\n    options.debounceEventsGuarantee,\n  )\n\n  function enqueueAddOrUpdate(item: any) {\n    const id = getId(item, service.store.idField)\n    if (!id)\n      return\n\n    set(addOrUpdateById, id, item)\n\n    if (hasOwn(removeItemsById.value, id))\n      del(removeItemsById, id)\n\n    flushAddOrUpdateQueue()\n  }\n\n  const flushRemoveItemQueue = _debounce(\n    () => {\n      const values = Object.values(removeItemsById.value)\n      if (values.length === 0)\n        return\n      service.store.removeFromStore(values)\n      removeItemsById.value = {}\n    },\n    options.debounceEventsTime || 20,\n    undefined,\n    options.debounceEventsGuarantee,\n  )\n\n  function enqueueRemoval(item: any) {\n    const id = getId(item, service.store.idField)\n    if (!id)\n      return\n\n    set(removeItemsById, id, item)\n\n    if (hasOwn(addOrUpdateById.value, id))\n      del(addOrUpdateById.value, id)\n\n    flushRemoveItemQueue()\n  }\n\n  function handleEvent(eventName: HandledEvents, item: any) {\n    const handler = (options.handleEvents as any)?.[eventName]\n    if (handler === false)\n      return\n\n    /**\n     * For `created` events, we don't know the id since it gets assigned on the server. Also, since `created` events\n     * arrive before the `create` response, we only act on other events. For all other events, toggle the event lock.\n     */\n    const id = getId(item, service.store.idField)\n    if (eventName !== 'created' && service.store.eventLocks[eventName][id]) {\n      service.store.toggleEventLock(id, eventName)\n      return\n    }\n\n    if (handler) {\n      const handled = handler(item, { service })\n      if (!handled)\n        return\n    }\n\n    if (!options.debounceEventsTime)\n      eventName === 'removed' ? service.store.removeFromStore(item) : service.store.createInStore(item)\n    else eventName === 'removed' ? enqueueRemoval(item) : enqueueAddOrUpdate(item)\n  }\n\n  // Listen to socket events when available.\n  service.on('created', (item: any) => {\n    const data = convertData(service, item)\n    handleEvent('created', data)\n  })\n  service.on('updated', (item: any) => {\n    const data = convertData(service, item)\n    handleEvent('updated', data)\n  })\n  service.on('patched', (item: any) => {\n    const data = convertData(service, item)\n    handleEvent('patched', data)\n  })\n  service.on('removed', (item: any) => {\n    const data = convertData(service, item)\n    handleEvent('removed', data)\n  })\n}\n","import type { HookContext, NextFunction } from '@feathersjs/feathers'\nimport { deepUnref } from '../utils/index.js'\n\n/**\n * deeply unrefs `params.query`\n */\nexport function unrefQuery() {\n  return async (context: HookContext, next: NextFunction) => {\n    if (context.params.value)\n      context.params = deepUnref(context.params)\n\n    if (context.params.query)\n      context.params.query = deepUnref(context.params.query)\n\n    if (context.method === 'find') {\n      const query = context.params.query || {}\n      if (query.$limit == null)\n        query.$limit = context.service.store.defaultLimit\n\n      if (query.$skip == null)\n        query.$skip = 0\n\n      context.params.query = query\n    }\n\n    next && await next()\n  }\n}\n","import type { HookContext, NextFunction } from '@feathersjs/feathers'\n\n/**\n * Controls pending state\n */\nexport function setPending() {\n  return async (context: HookContext, next: NextFunction) => {\n    const store = context.service.store\n    let unsetPending\n\n    if (!store.isSsr) {\n      const method = context.method === 'find' ? (context.params.query?.$limit === 0 ? 'count' : 'find') : context.method\n\n      store.setPending(method, true)\n      if (context.id != null && method !== 'get')\n        store.setPendingById(context.id, method, true)\n\n      const isTemp = context.data?.__isTemp\n      const tempId = context.data?.__tempId\n      if (isTemp && method === 'create')\n        store.setPendingById(context.data.__tempId, method, true)\n\n      unsetPending = () => {\n        store.setPending(method, false)\n        const id = context.id != null ? context.id : tempId\n        if (id != null && method !== 'get')\n          store.setPendingById(id, method, false)\n      }\n    }\n\n    try {\n      await next()\n    }\n    catch (error) {\n      if (unsetPending)\n        unsetPending()\n\n      throw error\n    }\n\n    if (unsetPending)\n      unsetPending()\n  }\n}\n","import type { HookContext, NextFunction } from '@feathersjs/feathers'\n\nexport function eventLocks() {\n  return async (context: HookContext, next: NextFunction) => {\n    const { id, method } = context\n    const store = context.service.store\n    const isLockableMethod = ['update', 'patch', 'remove'].includes(method)\n    const eventNames: any = {\n      update: 'updated',\n      patch: 'patched',\n      remove: 'removed',\n    }\n    const eventName = eventNames[method]\n\n    if (isLockableMethod && id && !store.isSsr)\n      store.toggleEventLock(id, eventName)\n\n    await next()\n\n    if (isLockableMethod && id && !store.isSsr)\n      store.clearEventLock(id, eventName)\n  }\n}\n","import type { HookContext, NextFunction } from '@feathersjs/feathers'\nimport { restoreTempIds } from '../utils/index.js'\n\nexport function syncStore() {\n  return async (context: HookContext, next: NextFunction) => {\n    const { method, params } = context\n    const store = context.service.store\n\n    if (method === 'patch' && params.data)\n      context.data = params.data\n\n    if (next)\n      await next()\n\n    if (!context.params.skipStore) {\n      if (method === 'remove') {\n        store.removeFromStore(context.result)\n      }\n      else if (method === 'create') {\n        const restoredTempIds = restoreTempIds(context.data, context.result)\n        context.result = store.createInStore(restoredTempIds)\n      }\n      else if (method === 'find' && Array.isArray(context.result.data)) {\n        context.result.data = store.createInStore(context.result.data)\n      }\n      else {\n        context.result = store.createInStore(context.result)\n      }\n\n      // Update pagination based on the qid\n      if (method === 'find' && context.result.total) {\n        const { qid = 'default', query, preserveSsr = false } = context.params\n        store.updatePaginationForQuery({ qid, response: context.result, query, preserveSsr })\n      }\n    }\n  }\n}\n","import type { HookContext, NextFunction } from '@feathersjs/feathers'\nimport type { AnyData } from '../types.js'\n\nexport function makeModelInstances() {\n  return async (context: HookContext, next: NextFunction) => {\n    if (next)\n      await next()\n\n    if (context.service.new) {\n      if (Array.isArray(context.result?.data))\n        context.result.data = context.result.data.map((i: AnyData) => context.service.new(i))\n\n      else if (Array.isArray(context.result))\n        context.result = context.result.map((i: AnyData) => context.service.new(i))\n\n      else\n        context.result = context.service.new(context.result)\n    }\n  }\n}\n","import type { HookContext, Id, NextFunction } from '@feathersjs/feathers'\n\n/**\n * Assures that the client reuses SSR-provided data instead of re-making the same query.\n *\n * Checks the `store.pagination` object to see if a query's results came from SSR-provided data.\n * If the data was from SSR, the SSR'd data is used and then set to `fromSSR = false` to allow\n * normal queries to happen again.\n */\nexport function handleFindSsr() {\n  return async (context: HookContext, next: NextFunction) => {\n    const store = context.service.store\n\n    if (context.method === 'find') {\n      const { params } = context\n      const info = store.getQueryInfo(params)\n      const qidData = store.pagination[info.qid]\n      const queryData = qidData?.[info.queryId]\n      const pageData = queryData?.[info.pageId as string]\n\n      if (pageData?.ssr) {\n        context.result = {\n          data: pageData.ids.map((id: Id) => store.getFromStore(id).value),\n          limit: pageData.pageParams.$limit,\n          skip: pageData.pageParams.$skip,\n          total: queryData.total,\n          fromSsr: true,\n        }\n        if (!params.preserveSsr)\n          store.unflagSsr(params)\n      }\n    }\n\n    if (next)\n      await next()\n  }\n}\n","import type { HookContext, NextFunction } from '@feathersjs/feathers'\nimport { hasOwn } from '../utils/index.js'\n\n/**\n * Normalizes two things\n *  - pagination across all adapters, including @feathersjs/memory\n *  - the find response so that it always holds data at `response.data`\n * @returns { data: AnyData[] }\n */\nexport function normalizeFind() {\n  return async (context: HookContext, next?: NextFunction) => {\n  // Client-side services, like feathers-memory, require paginate.default to be truthy.\n    if (context.method === 'find') {\n      const { params } = context\n      const { query = {} } = params\n      const isPaginated = params.paginate === true || hasOwn(query, '$limit') || hasOwn(query, '$skip')\n      if (isPaginated)\n        params.paginate = { default: true }\n    }\n\n    next && await next()\n\n    // if (context.method === 'find' && !context.result?.data) {\n    // context.result = { data: context.result }\n    // }\n  }\n}\n","import type { HookContext, NextFunction } from '@feathersjs/feathers'\n\nexport function skipGetIfExists() {\n  return async (context: HookContext, next: NextFunction) => {\n    const { params, id } = context\n    const store = context.service.store\n\n    if (context.method === 'get' && id != null) {\n      const skipIfExists = params.skipGetIfExists || store.skipGetIfExists\n      delete params.skipGetIfExists\n\n      // If the records is already in store, return it\n      const existingItem = store.getFromStore(context.id, params)\n      if (existingItem && skipIfExists)\n        context.result = existingItem\n    }\n    await next()\n  }\n}\n","import type { HookContext, NextFunction } from '@feathersjs/feathers'\nimport fastCopy from 'fast-copy'\nimport { diff, pickDiff } from '../utils/index.js'\n\nexport function patchDiffing() {\n  return async (context: HookContext, next: NextFunction) => {\n    const { method, data, params, id } = context\n    const store = context.service.store\n\n    let rollbackData: any\n    let clone: any\n    const shouldDiff = method === 'patch' && !params.data && (data.__isClone || params.diff)\n\n    if (shouldDiff) {\n      clone = data\n      const original = store.getFromStore(id).value\n      const diffedData = diff(original, clone, params.diff)\n      rollbackData = fastCopy(original)\n\n      // Do eager updating.\n      if (params.eager !== false)\n        data.commit(diffedData)\n\n      // Always include matching values from `params.with`.\n      if (params.with) {\n        const dataFromWith = pickDiff(clone, params.with)\n        // If params.with was an object, merge the values into dataFromWith\n        if (typeof params.with !== 'string' && !Array.isArray(params.with))\n          Object.assign(dataFromWith, params.with)\n\n        Object.assign(diffedData, dataFromWith)\n      }\n\n      context.data = diffedData\n\n      // If diff is empty, return the clone without making a request.\n      if (Object.keys(context.data).length === 0)\n        context.result = clone\n    }\n    else {\n      context.data = fastCopy(data)\n    }\n\n    try {\n      await next()\n    }\n    catch (error) {\n      if (shouldDiff) {\n        // If saving fails, reverse the eager update\n        clone && clone.commit(rollbackData)\n      }\n      throw error\n    }\n  }\n}\n","import type { HookContext, NextFunction } from '@feathersjs/feathers'\n\n/**\n * Prevents duplicate requests by cacheing results from qid-enabled queries.\n * Clears the cache on the client after 500ms.\n */\nexport function handleQidCache() {\n  return async (context: HookContext, next: NextFunction) => {\n    const { params } = context\n    const store = context.service.store\n\n    // Reuse any cached results for the same qid\n    // this prevents duplicate requests on the server and client.\n    // The client will cache the result for 500ms. It is assumed that all startup\n    // requests will be completed within 500ms.\n    if (params.qid) {\n      const cached = store.getQid(params.qid)\n\n      // specifically check for undefined because null is a valid value\n      if (cached !== undefined) {\n        // on the client, schedule the value to be removed from the cache after 500ms\n        if (!store.isSsr) {\n          setTimeout(() => {\n            store.clearQid(params.qid)\n          }, 500)\n        }\n\n        // set the result to prevent the request\n        context.result = cached\n        return await next()\n      }\n    }\n\n    await next()\n\n    // on the ssr server, cache the result if params.qid is set\n    if (params.qid && store.isSsr)\n      store.setQid(params.qid, context.result)\n  }\n}\n","import { unrefQuery } from './0-prepare-query.js'\nimport { setPending } from './1-set-pending.js'\nimport { eventLocks } from './2-event-locks.js'\nimport { syncStore } from './3-sync-store.js'\nimport { makeModelInstances } from './4-model-instances.js'\nimport { handleFindSsr } from './5-handle-find-ssr.js'\nimport { normalizeFind } from './6-normalize-find.js'\nimport { skipGetIfExists } from './7-skip-get-if-exists.js'\nimport { patchDiffing } from './8-patch-diffs.js'\nimport { handleQidCache } from './9-ssr-qid-cache.js'\n\nexport { syncStore, setPending, eventLocks, normalizeFind, skipGetIfExists, makeModelInstances }\n\nexport function feathersPiniaHooks() {\n  return [\n    unrefQuery(),\n    setPending(),\n    eventLocks(),\n    syncStore(),\n    makeModelInstances(),\n    handleFindSsr(),\n    normalizeFind(),\n    skipGetIfExists(),\n    patchDiffing(),\n    handleQidCache(),\n  ]\n}\n","import { BadRequest } from '@feathersjs/errors'\nimport type { FeathersService, Params } from '@feathersjs/feathers'\nimport type { AnyData } from '../types.js'\nimport { defineGetters, defineValues } from '../utils/define-properties'\nimport type { PiniaService } from '../create-pinia-service.js'\nimport type { ServiceInstanceProps } from './types.js'\n\nexport type Service = FeathersService | PiniaService<FeathersService>\n\nexport interface useServiceInstanceOptions<S extends Service> {\n  service: S\n  store: any\n}\n\nexport function useServiceInstance<M extends AnyData, S extends Service, P extends Params = Params>(data: M,\n  options: useServiceInstanceOptions<S>) {\n  if (data.__isServiceInstance)\n    return data\n\n  const { service, store } = options\n  const merge = (data: M, toMerge: AnyData) => Object.assign(data, toMerge)\n\n  defineGetters(data, {\n    isPending() {\n      return this.isCreatePending || this.isPatchPending || this.isRemovePending\n    },\n    isSavePending() {\n      return this.isCreatePending || this.isPatchPending\n    },\n    isCreatePending() {\n      return !!(store.createPendingById[this[store.idField]] || store.createPendingById[this.__tempId])\n    },\n    isPatchPending() {\n      return !!store.patchPendingById[this[store.idField]]\n    },\n    isRemovePending() {\n      return !!store.removePendingById[this[store.idField]]\n    },\n  } as any)\n\n  defineValues(data, {\n    __isServiceInstance: true,\n    save(this: M, params?: P) {\n      const id = this[store.idField]\n      return id != null ? this.patch(params) : this.create(params)\n    },\n    create(this: M, params?: P): Promise<M> {\n      return service.create(this, params).then(result => merge(this, result))\n    },\n    patch(this: M, params?: P): Promise<M> {\n      const id = this[store.idField]\n      if (id === undefined)\n        throw new BadRequest('the item has no id')\n      return (service as FeathersService).patch(id as any, this as any, params as any).then(result => merge(this, result))\n    },\n    remove(this: M, params?: P): Promise<M> {\n      if (this.__isTemp) {\n        store.removeFromStore(this.__tempId)\n        return Promise.resolve(this)\n      }\n      else {\n        const id = this[store.idField]\n        return (service as FeathersService).remove(id, params).then(result => merge(this, result))\n      }\n    },\n  })\n\n  return data as M & ServiceInstanceProps<M, AnyData, P>\n}\n","import { defineValues } from '../utils/index.js'\n\nexport function storeAssociated(this: any, data: any, config: Record<string, string>) {\n  const updatedValues: any = {}\n  Object.keys(config).forEach((key) => {\n    const related = data[key]\n    const servicePath = config[key]\n    const service = this.service(servicePath)\n    if (!service)\n      console.error(`there is no service at path ${servicePath}. Check your storeAssociated config`, data, config)\n    if (related && service) {\n      const created = service.createInStore(related)\n      updatedValues[key] = created\n    }\n  })\n\n  defineValues(data, updatedValues)\n}\n","import { computed, watch } from 'vue-demi'\nimport { _ } from '@feathersjs/commons'\nimport debounce from 'just-debounce'\n\n// Writes data to localStorage\nexport function writeToStorage(id: string, data: any, storage: any) {\n  const compressed = JSON.stringify(data)\n  storage.setItem(id, compressed)\n}\n\n// Moves data from localStorage into the store\nexport function hydrateStore(store: any, storage: any) {\n  const data = storage.getItem(store.$id)\n  if (data) {\n    const hydrationData = JSON.parse(data as string) || {}\n    Object.assign(store, hydrationData)\n  }\n}\n\n/**\n *\n * @param store pinia store\n * @param keys an array of keys to watch and write to localStorage.\n */\nexport function syncWithStorage(store: any, stateKeys: Array<string>, storage: Storage = window.localStorage) {\n  hydrateStore(store, storage)\n\n  const debouncedWrite = debounce(writeToStorage, 500)\n  const toWatch = computed(() => _.pick(store, ...stateKeys))\n\n  watch(toWatch, val => debouncedWrite(store.$id, val, storage), { deep: true })\n}\n","/**\n * Clears all services from localStorage. You might use this when a user\n * logs out to make sure their data doesn't persist for the next user.\n *\n * @param storage an object using the Storage interface\n */\nexport function clearStorage(storage: Storage = window.localStorage) {\n  const prefix = 'service:' // replace this with your prefix\n  for (let i = 0; i < storage.length; i++) {\n    const key = storage.key(i)\n    if (key?.startsWith(prefix))\n      storage.removeItem(key)\n  }\n}\n","import type { Application, FeathersService } from '@feathersjs/feathers'\nimport { feathers } from '@feathersjs/feathers'\nimport { defineStore } from 'pinia'\nimport type { HandleEvents } from './stores/index.js'\nimport type { AnyData } from './types.js'\nimport { PiniaService } from './create-pinia-service.js'\nimport type { Service } from './modeling/use-feathers-instance.js'\nimport { useServiceEvents, useServiceStore } from './stores/index.js'\nimport { feathersPiniaHooks } from './hooks/index.js'\nimport { storeAssociated, useServiceInstance } from './modeling/index.js'\nimport { defineGetters, defineVirtualProperties, defineVirtualProperty, pushToStore } from './utils/index.js'\nimport { syncWithStorage as __sync, clearStorage } from './localstorage/index.js'\n\nexport interface SetupInstanceUtils {\n  app?: any\n  service?: any\n  servicePath?: string\n}\n\nexport interface PiniaServiceConfig {\n  /**\n   * The name of the store to use for this service. Defaults to `service:${servicePath}`.\n   * You can also use storeName to make two services share the same store.\n   */\n  storeName?: string\n  /**\n   * Overrides the service used for instance-level service methods, like patch, and remove.\n   * Useful for \"proxy\" services. For example: `pages/full` loads the page record with populated\n   * data, but you want to patch/remove the record through the `pages` service.\n   */\n  instanceServicePath?: string\n  idField?: string\n  defaultLimit?: number\n  syncWithStorage?: boolean | string[]\n  whitelist?: string[]\n  paramsForServer?: string[]\n  skipGetIfExists?: boolean\n  handleEvents?: HandleEvents<AnyData>\n  debounceEventsTime?: number\n  debounceEventsGuarantee?: boolean\n  setupInstance?: (data: any, utils: SetupInstanceUtils) => any\n  customizeStore?: (data: ReturnType<typeof useServiceStore>) => Record<string, any>\n  customSiftOperators?: Record<string, any>\n}\n\nexport interface CreatePiniaClientConfig extends PiniaServiceConfig {\n  idField: string\n  pinia: any\n  ssr?: boolean\n  storage?: Storage\n  services?: Record<string, PiniaServiceConfig>\n}\n\nexport type AppWithServices = {\n  services: { [key: string]: FeathersService }\n}\n\nexport type CreatePiniaServiceTypes<T extends AppWithServices> = {\n  [Key in keyof T['services']]: PiniaService<T['services'][Key]> & T['services'][Key]\n}\n\nexport interface AppExtensions {\n  storeAssociated: (data: any, config: Record<string, string>) => void\n  clearStorage: () => void\n  pushToStore: <Data>(data: Data, servicePath: string) => void\n  defineVirtualProperty: <Data>(data: Data, key: string, getter: any) => void\n  defineVirtualProperties: <Data>(data: Data, getters: Record<string, any>) => void\n}\n\n/**\n * ```ts\n * import { FeathersPiniaClient } from 'feathers-pinia'\n * import { Application, Service } from '@feathersjs/feathers'\n * interface Book {\n *   id: string\n *   title: string\n * }\n * interface ServiceTypes {\n *   books: Service<Book>\n * }\n * export type MyFeathersPiniaApp = FeathersPiniaClient<Application<ServiceTypes>>\n * ```\n */\nexport type FeathersPiniaClient<App extends Application> = Application<CreatePiniaServiceTypes<App>> & AppExtensions\n\nexport function createPiniaClient<App extends Application>(\n  client: App,\n  options: CreatePiniaClientConfig,\n): Application<CreatePiniaServiceTypes<App>> & AppExtensions {\n  const vueApp = feathers()\n\n    ;(vueApp as any).defaultService = function (location: string) {\n    const serviceOptions = options.services?.[location] || {}\n\n    // combine service and global options\n    const idField = serviceOptions.idField || options.idField\n    const defaultLimit = serviceOptions.defaultLimit || options.defaultLimit || 10\n    const whitelist = (serviceOptions.whitelist || []).concat(options.whitelist || [])\n    const paramsForServer = (serviceOptions.paramsForServer || []).concat(options.paramsForServer || [])\n    const handleEvents = serviceOptions.handleEvents || options.handleEvents\n    const debounceEventsTime\n      = serviceOptions.debounceEventsTime != null ? serviceOptions.debounceEventsTime : options.debounceEventsTime\n    const debounceEventsGuarantee\n      = serviceOptions.debounceEventsGuarantee != null\n        ? serviceOptions.debounceEventsGuarantee\n        : options.debounceEventsGuarantee\n    const customSiftOperators = Object.assign(\n      {},\n      serviceOptions.customSiftOperators || {},\n      options.customSiftOperators || {},\n    )\n    function customizeStore(utils: any) {\n      const fromGlobal = Object.assign(utils, options.customizeStore ? options.customizeStore(utils) : utils)\n      const fromService = Object.assign(\n        fromGlobal,\n        serviceOptions.customizeStore ? serviceOptions.customizeStore(fromGlobal) : fromGlobal,\n      )\n      return fromService\n    }\n\n    function wrappedSetupInstance(data: any) {\n      // if serviceOptions.instanceServicePath is set, it's an instance-level override, so use that instead of location\n      const servicePath = serviceOptions.instanceServicePath || location\n      const service = vueApp.service(servicePath) as Service\n\n      const asFeathersModel = useServiceInstance(data, {\n        service,\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        store,\n      })\n\n      // call the provided `setupInstance`\n      const utils = { app: vueApp, service, servicePath }\n      const fromGlobal = options.setupInstance ? options.setupInstance(asFeathersModel, utils) : asFeathersModel\n      const serviceLevel = serviceOptions.setupInstance ? serviceOptions.setupInstance(fromGlobal, utils) : fromGlobal\n      return serviceLevel\n    }\n\n    // create pinia store, or reuse existing one by storeName\n    const storeName = serviceOptions.storeName || `service:${location}`\n    const existingStore = options.pinia._s.get(storeName)\n    let store: any\n    if (existingStore) {\n      store = existingStore\n    }\n    else {\n      const useStore = defineStore(storeName, () => {\n        const utils = useServiceStore({\n          idField,\n          servicePath: location,\n          defaultLimit,\n          whitelist,\n          paramsForServer,\n          customSiftOperators,\n          ssr: options.ssr,\n          setupInstance: wrappedSetupInstance,\n        })\n        const custom = customizeStore(utils)\n        return { ...utils, ...custom }\n      })\n      store = useStore(options.pinia)\n    }\n\n    // storage-sync\n    if (!options.ssr && options.storage) {\n      const defaultStorageKeys = ['itemsById', 'pagination']\n      const globalStorageKeys\n        = options.syncWithStorage === true\n          ? defaultStorageKeys\n          : Array.isArray(options.syncWithStorage)\n            ? options.syncWithStorage\n            : []\n      const serviceStorageKeys\n        = serviceOptions.syncWithStorage === true\n          ? defaultStorageKeys\n          : Array.isArray(serviceOptions.syncWithStorage)\n            ? serviceOptions.syncWithStorage\n            : []\n      const syncWithStorage = [...new Set([...globalStorageKeys, ...serviceStorageKeys])]\n      const shouldSyncStorage = syncWithStorage.length > 0\n      if (shouldSyncStorage)\n        __sync(store, syncWithStorage, options.storage)\n    }\n\n    const clientService = client.service(location)\n    const piniaService = new PiniaService(clientService, { store, servicePath: location })\n\n    useServiceEvents({\n      service: piniaService,\n      debounceEventsTime,\n      debounceEventsGuarantee,\n      handleEvents,\n    })\n\n    return piniaService\n  }\n\n  // register hooks on every service\n  const mixin: any = (service: any) => {\n    service.hooks({\n      around: feathersPiniaHooks(),\n    })\n  }\n  vueApp.mixins.push(mixin)\n\n  defineGetters(vueApp, {\n    authentication() {\n      return (client as any).authentication\n    },\n    authenticate() {\n      return (client as any).authenticate\n    },\n    reAuthenticate() {\n      return (client as any).reAuthenticate\n    },\n    logout() {\n      return (client as any).logout\n    },\n    clearStorage() {\n      if (!options.ssr && options.storage)\n        return clearStorage(options.storage)\n    },\n  })\n\n  Object.assign(vueApp, {\n    // TODO: remove in v5\n    storeAssociated,\n    pushToStore<Data>(data: Data, servicePath: string) {\n      const service = vueApp.service(servicePath) as unknown as { createInStore: any }\n      return pushToStore(data, service)\n    },\n    defineVirtualProperty,\n    defineVirtualProperties,\n  })\n\n  return vueApp as FeathersPiniaClient<App>\n}\n","import { FetchClient } from '@feathersjs/rest-client'\nimport type { Params } from '@feathersjs/feathers'\n\n// A feathers-rest transport adapter for https://github.com/unjs/ofetch\nexport class OFetch extends FetchClient {\n  async request(options: any, params: Params) {\n    const fetchOptions = Object.assign({}, options, (params as any).connection)\n\n    fetchOptions.headers = Object.assign({ Accept: 'application/json' }, this.options.headers, fetchOptions.headers)\n\n    if (options.body)\n      fetchOptions.body = options.body\n\n    try {\n      const response = await this.connection.raw(options.url, fetchOptions)\n      const { _data, status } = response\n\n      if (status === 204)\n        return null\n      return _data\n    }\n    catch (error: any) {\n      throw error.data\n    }\n  }\n}\n","export const feathersPiniaAutoImport = {\n  'feathers-pinia': [\n    'useServiceInstance',\n    'useInstanceDefaults',\n    'useDataStore',\n    'useAuth',\n    'createPiniaClient',\n    'defineGetters',\n    'defineSetters',\n    'defineValues',\n    'useBackup',\n  ],\n}\n","export class InvalidTokenError extends Error {\n}\nInvalidTokenError.prototype.name = \"InvalidTokenError\";\nfunction b64DecodeUnicode(str) {\n    return decodeURIComponent(atob(str).replace(/(.)/g, (m, p) => {\n        let code = p.charCodeAt(0).toString(16).toUpperCase();\n        if (code.length < 2) {\n            code = \"0\" + code;\n        }\n        return \"%\" + code;\n    }));\n}\nfunction base64UrlDecode(str) {\n    let output = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    switch (output.length % 4) {\n        case 0:\n            break;\n        case 2:\n            output += \"==\";\n            break;\n        case 3:\n            output += \"=\";\n            break;\n        default:\n            throw new Error(\"base64 string is not of the correct length\");\n    }\n    try {\n        return b64DecodeUnicode(output);\n    }\n    catch (err) {\n        return atob(output);\n    }\n}\nexport function jwtDecode(token, options) {\n    if (typeof token !== \"string\") {\n        throw new InvalidTokenError(\"Invalid token specified: must be a string\");\n    }\n    options || (options = {});\n    const pos = options.header === true ? 0 : 1;\n    const part = token.split(\".\")[pos];\n    if (typeof part !== \"string\") {\n        throw new InvalidTokenError(`Invalid token specified: missing part #${pos + 1}`);\n    }\n    let decoded;\n    try {\n        decoded = base64UrlDecode(part);\n    }\n    catch (e) {\n        throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${pos + 1} (${e.message})`);\n    }\n    try {\n        return JSON.parse(decoded);\n    }\n    catch (e) {\n        throw new InvalidTokenError(`Invalid token specified: invalid json for part #${pos + 1} (${e.message})`);\n    }\n}\n","import type { Ref } from 'vue-demi'\nimport type { NullableId } from '@feathersjs/feathers'\nimport { computed, ref } from 'vue-demi'\nimport { jwtDecode } from 'jwt-decode'\nimport { useCounter } from '../utils/use-counter'\n\ntype SuccessHandler = (result: Record<string, any>) => Promise<Record<string, any> | void>\ntype ErrorHandler = (error: Error) => Promise<void>\n\ninterface UseAuthOptions {\n  api: any\n  servicePath?: string\n  skipTokenCheck?: boolean\n  entityKey?: string\n  onSuccess?: SuccessHandler\n  onError?: ErrorHandler\n  onInitSuccess?: SuccessHandler\n  onInitError?: ErrorHandler\n  onLogoutSuccess?: SuccessHandler\n  onLogoutError?: ErrorHandler\n}\n\ninterface AuthenticateData {\n  strategy: 'jwt' | 'local'\n  accessToken?: string\n  email?: string\n  password?: string\n}\n\nexport function useAuth<d = AuthenticateData>(options: UseAuthOptions) {\n  const { api, servicePath, skipTokenCheck } = options\n  const entityService = servicePath ? api.service(servicePath) : null\n  const entityKey = options.entityKey || 'user'\n\n  // external flow\n  const promise = ref() as Ref<Promise<Record<string, any>>>\n  const defaultHandler = async () => undefined\n  const defaultErrorHandler = async (error: any) => {\n    throw error\n  }\n  const onSuccess: SuccessHandler = options.onSuccess || defaultHandler\n  const onError: ErrorHandler = options.onError || defaultErrorHandler\n  const onInitSuccess: SuccessHandler = options.onInitSuccess || defaultHandler\n  const onInitError: ErrorHandler = options.onInitError || defaultHandler\n  const onLogoutSuccess: SuccessHandler = options.onLogoutSuccess || defaultHandler\n  const onLogoutError: ErrorHandler = options.onLogoutError || defaultErrorHandler\n\n  // user\n  const userId = ref<NullableId>(null)\n  const user = computed(() => {\n    if (!entityService)\n      return null\n    const u = entityService?.getFromStore(userId)\n    return u.value || null\n  })\n\n  // error\n  const error = ref<Error | null>(null)\n  const clearError = () => (error.value = null)\n\n  // authenticate\n  const authCounter = useCounter()\n  const isPending = computed(() => !!authCounter.count.value)\n  const isAuthenticated = ref(false)\n  const handleAuthResult = (result: any) => {\n    const entity = result[entityKey]\n    if (entityService && entity) {\n      const stored = entityService.store.createInStore(entity)\n      userId.value = stored[entityService.store.idField] || stored.__tempId\n    }\n    isAuthenticated.value = true\n    return result\n  }\n  const authenticate = async (data?: d) => {\n    authCounter.add()\n    clearError()\n    promise.value = api\n      .authenticate(data)\n      .then(handleAuthResult)\n      .then(async (result: Record<string, any>) => {\n        const _result = await onSuccess(result)\n        return _result || result\n      })\n      .catch((err: any) => {\n        error.value = err\n        return onError(err)\n      })\n      .finally(() => {\n        authCounter.sub()\n      })\n    return promise.value\n  }\n\n  // token check\n  const isTokenExpired = (jwt: string) => {\n    try {\n      const payload = jwtDecode(jwt) as any\n      return new Date().getTime() > payload.exp * 1000\n    }\n    catch (error) {\n      return false\n    }\n  }\n\n  // reauthentication at app start\n  const isInitDone = ref(false)\n  const reAuthenticate = async () => {\n    authCounter.add()\n    promise.value = api.reAuthenticate()\n      .then(handleAuthResult)\n      .then(async (result: Record<string, any>) => {\n        const _result = await onInitSuccess(result)\n        return _result || result\n      })\n      .catch((error: any) => {\n        error.value = error\n        return onInitError(error)\n      })\n      .finally(() => {\n        authCounter.sub()\n        isInitDone.value = true\n      })\n    return promise.value\n  }\n\n  // logout\n  const logoutCounter = useCounter()\n  const isLogoutPending = computed(() => !!logoutCounter.count.value)\n  const logout = async () => {\n    logoutCounter.add()\n    return api\n      .logout()\n      .then((response: any) => {\n        userId.value = null\n        isAuthenticated.value = false\n        return response\n      })\n      .then(onLogoutSuccess)\n      .catch((error: any) => {\n        error.value = error\n        return onLogoutError(error)\n      })\n      .finally(() => logoutCounter.sub())\n  }\n\n  // login redirect\n  const loginRedirect = ref<string | Record<string, any> | null>(null)\n\n  return {\n    user,\n    error,\n    isPending,\n    isLogoutPending,\n    isInitDone,\n    isAuthenticated,\n    loginRedirect,\n    getPromise: () => promise.value,\n    isTokenExpired,\n    authenticate,\n    reAuthenticate,\n    logout,\n    clearError,\n  }\n}\n","import { copyStrict } from 'fast-copy'\nimport { isRef, ref, unref, watch } from 'vue'\nimport type { ComputedRef, Ref } from 'vue'\nimport { diff } from '../utils/utils'\nimport type { AnyData, DiffDefinition } from '../types'\n\ntype AnyRef<D> = Ref<D> | ComputedRef<D>\n\ninterface UseBackupOptions<D> {\n  onlyProps?: keyof D\n  idField?: keyof D\n}\n\n/**\n * Provides a backup of the current instance, and methods to save and restore it.\n * The `save` method will diff the current instance with the backup. Any values in the new\n * instance that are different in the old instance will be passed to the save method as data.\n */\nexport function useBackup<D extends AnyData>(data: AnyRef<D>, options?: UseBackupOptions<D>) {\n  const backup = ref<any>(null)\n\n  // automatically update if the record changes\n  watch(data, async (val: any) => {\n    if (!data)\n      return\n\n    const idField = options?.idField\n    const id = idField ? val?.[idField] : val?.id\n    const backupId = idField ? backup.value?.[idField] : backup.value?.id\n    if (id !== backupId)\n      backup.value = copyStrict(val)\n  }, { immediate: true })\n\n  /**\n   * Diff the current instance with the backup. Any values in the new instance that are\n   * different in the old instance will be passed to the save method as data.\n   */\n  async function save() {\n    const toDiff = unref(data as any)\n    const diffData = diff(backup.value, toDiff, options?.onlyProps as DiffDefinition)\n    // if any keys were different...\n    if (Object.keys(diffData).length) {\n      // save the diff\n      try {\n        const withUpdates = await data.value.save({ data: diffData })\n\n        // update the backup to match the new instance\n        backup.value = copyStrict(withUpdates)\n      }\n      catch (error) {\n        console.error('could not save', error)\n        throw error\n      }\n    }\n    // if nothing changed, return the original record\n    else { return toDiff }\n  }\n\n  function restore(currentInstance: any) {\n    if (backup.value) {\n      const target = isRef(currentInstance) ? currentInstance.value : currentInstance\n      Object.assign(target, backup.value)\n    }\n    return currentInstance\n  }\n\n  return { data, backup, save, restore }\n}\n"],"names":["fastDeepEqual","equal","a","b","length","i","keys","key","toStringFunction","create","toStringObject","LegacyCache","value","createCacheLegacy","createCacheModern","createCache","getCleanClone","prototype","Constructor","getRegExpFlagsLegacy","regExp","flags","getRegExpFlagsModern","getRegExpFlags","getTagLegacy","type","getTagModern","getTag","defineProperty","getOwnPropertyDescriptor","getOwnPropertyNames","getOwnPropertySymbols","_a","hasOwnProperty","propertyIsEnumerable","SUPPORTS_SYMBOL","getStrictPropertiesModern","object","getStrictProperties","copyOwnPropertiesStrict","clone","state","properties","index","length_1","property","descriptor","copyArrayLoose","array","length_2","copyArrayStrict","copyArrayBuffer","arrayBuffer","_state","copyBlob","blob","copyDataView","dataView","copyDate","date","copyMapLoose","map","copyMapStrict","copyObjectLooseLegacy","copyObjectLooseModern","symbols","length_3","symbol","copyObjectLoose","copyObjectStrict","copyPrimitiveWrapper","primitiveObject","copyRegExp","copySelf","copySetLoose","set","copySetStrict","isArray","assign","getPrototypeOf","obj","DEFAULT_LOOSE_OPTIONS","DEFAULT_STRICT_OPTIONS","getTagSpecificCopiers","options","createCopier","normalizedOptions","tagSpecificCopiers","copier","tagSpecificCopier","createStrictCopier","copyStrict","defineValues","data","defineGetters","defineSetters","convertData","service","result","getExtendedQueryInfo","queryInfo","store","qid","queryState","total","pageState","ids","queriedAt","ssr","id","items","hasOwn","prop","getArray","pickDiff","diffDef","topLevelKeys","_","diff","dest","source","originalVal","cloneVal","isEqual","restoreTempIds","resData","tempIdField","sourceItems","responseItems","item","tempId","stringifyIfObject","val","getId","idField","getParams","params","fastCopy","unref","timeout","ms","resolve","useCounter","count","ref","isObject","smartUnref","isRef","deepUnref","unrefArray","arr","unrefObject","unreffed","checkedVal","useInstanceDefaults","defaults","dataKeys","defaultsToApply","pushToStore","createInStore","defineVirtualProperty","getter","definition","defineVirtualProperties","getters","existingServiceMethods","toValue","r","noop","createFilterWrapper","filter","fn","wrapper","args","reject","debounceFilter","timer","maxTimer","lastRejector","_clearTimeout","timer2","invoke","duration","maxDuration","useDebounceFn","fastJsonStableStringify","opts","cycles","cmp","f","node","aobj","bobj","seen","stringify","out","seenIndex","getIdsFromQueryInfo","pagination","queryId","pageId","queryLevel","pageLevel","itemsFromPagination","usePageData","limit","skip","request","pageCount","computed","currentPage","pageNumber","newSkip","skipVal","canPrev","canNext","wait","page","useFind","deps","debounce","immediate","_watch","paginateOn","_b","_d","_c","paramsWithPagination","query","paramsWithoutPagination","queryShallowCopy","isPending","haveBeenRequested","haveLoaded","error","clearError","cachedParams","updateCachedParams","queryWhenFn","queryWhen","_queryWhenFn","cachedQuery","currentQuery","allLocalData","itemsBeforeCurrent","whichQuery","allItems","firstOfCurrentPage","indexInItems","adjustedIndex","localParams","beforeCurrent","adjustedSkip","queries","latestQuery","previousQuery","requestCount","setupPendingState","find","__params","___params","response","extendedQueryInfo","err","findDebounced","makeRequest","p","pageData","toStart","toEnd","toPage","next","prev","watch","reactive","useGet","_id","_params","isSsr","hasBeenRequested","mostRecentId","getFromStore","hasLoaded","get","PiniaService","__publicField","keysToIgnore","instance","asInstance","idOrData","results","eventName","listener","_increment","_pid","_machine","storage","mongoMachineId","ObjectID","strOid","timestamp","machine","pid","increment","module","isomorphicMongoObjectid","require$$0","useModelInstance","clonesById","commit","reset","removeFromStore","__isClone","extendStatics","d","__extends","__","typeChecker","typeString","getClassName","comparable","coercePotentiallyNull","isFunction","isVanillaObject","equals","walkKeyPathValues","keyPath","depth","owner","currentKey","BaseOperation","owneryQuery","name","GroupOperation","_super","children","_this","root","done","keep","childOperation","NamedGroupOperation","QueryOperation","parent","NestedOperation","createTester","compare","comparableA","EqualsOperation","createEqualsOperation","numericalOperationCreator","createNumericalOperation","numericalOperation","typeofParams","test","actualValue","createNamedOperation","parentQuery","operationCreator","throwUnsupportedOperation","containsOperation","createNestedOperation","nestedQuery","parentKey","createQueryOperations","selfOperations","nestedOperations","createQueryOperation","operations","ops","op","createOperationTester","operation","$Ne","$ElemMatch","child","$Not","$Size","assertGroupNotEmpty","values","$Or","success","$Nor","$In","length_4","$Nin","ownerQuery","$Exists","$And","$All","$eq","$ne","$or","$nor","$elemMatch","$nin","$in","$lt","$lte","$gt","$gte","$mod","mod","equalsValue","$exists","$regex","pattern","$not","typeAliases","v","$type","clazz","$and","$all","$size","$options","$where","defaultOperations","createDefaultQueryOperation","createDefaultQueryTester","like","search","regexOptions","specials","iLike","str","$like","$notLike","$ilike","$notILike","sqlOperations","FILTERS","additionalOperators","useServiceLocal","itemStorage","tempStorage","cloneStorage","addItemToStorage","paramsForServer","whitelist","customSiftOperators","_filterQueryOperators","filterItems","startingValues","_paramsForServer","q","filters","filterQuery","sift","findInStore","filtered","sorter","findOneInStore","countInStore","existingItem","select","tempItem","_items","patchInStore","_idOrData","_data","updateItems","toWrite","fromStore","patchedItems","clones","removeItems","useServiceStorage","onRead","beforeWrite","src","byId","list","hasItem","has","getItem","inStore","setItem","vueSet","merge","existing","removeItem","hadItem","vueDel","useServiceTemps","moveTempToItems","useServiceClones","defaultMakeCopy","isClone","makeCopy","assureOriginalIsStored","existingClone","itemId","_item","original","copied","vueDelete","markAsClone","useAllStorageTypes","getIdField","setupInstance","makeDefaultOptions","useDataStore","_options","asBaseModel","afterSetup","clearAll","debug","debuggers","noopDebug","defaultInitializer","setDebug","createDebug","__createBinding","this","m","k","k2","desc","__exportStar","exports","stripSlashes","callback","first","rest","target","isPromise","createSymbol","useServicePagination","defaultLimit","clearPagination","defaultSkip","updatePaginationForQuery","preserveSsr","queryParams","pageParams","getQueryInfo","mostRecent","existingPageData","qidData","queryData","newState","unflagSsr","$limit","$skip","defaultPending","useServicePending","createPendingById","updatePendingById","patchPendingById","removePendingById","isFindPending","isCountPending","isGetPending","isCreatePending","isUpdatePending","isPatchPending","isRemovePending","setPending","method","setPendingById","place","del","unsetPendingById","clearAllPending","useServiceEventLocks","eventLocks","toggleEventLock","event","clearEventLock","useSsrQueryCache","resultsByQid","getQid","setQid","clearQid","clearAllQids","useServiceStore","servicePath","pendingState","makeGetterName","makeState","useQueuePromise","stopWatching","justDebounce","delay","atStart","guarantee","self","clear","run","useServiceEvents","addOrUpdateById","removeItemsById","flushAddOrUpdateQueue","_debounce","enqueueAddOrUpdate","flushRemoveItemQueue","enqueueRemoval","handleEvent","handler","unrefQuery","context","unsetPending","isTemp","isLockableMethod","syncStore","restoredTempIds","makeModelInstances","handleFindSsr","info","normalizeFind","skipGetIfExists","skipIfExists","patchDiffing","rollbackData","shouldDiff","diffedData","dataFromWith","handleQidCache","cached","feathersPiniaHooks","useServiceInstance","toMerge","BadRequest","storeAssociated","config","updatedValues","related","created","writeToStorage","compressed","hydrateStore","hydrationData","syncWithStorage","stateKeys","debouncedWrite","toWatch","clearStorage","prefix","createPiniaClient","client","vueApp","feathers","location","serviceOptions","handleEvents","debounceEventsTime","debounceEventsGuarantee","customizeStore","utils","fromGlobal","wrappedSetupInstance","asFeathersModel","storeName","existingStore","defineStore","custom","defaultStorageKeys","globalStorageKeys","serviceStorageKeys","__sync","clientService","piniaService","mixin","OFetch","FetchClient","fetchOptions","status","feathersPiniaAutoImport","InvalidTokenError","b64DecodeUnicode","code","base64UrlDecode","output","jwtDecode","token","pos","part","decoded","e","useAuth","api","skipTokenCheck","entityService","entityKey","promise","defaultHandler","defaultErrorHandler","onSuccess","onError","onInitSuccess","onInitError","onLogoutSuccess","onLogoutError","userId","user","authCounter","isAuthenticated","handleAuthResult","entity","stored","authenticate","isTokenExpired","jwt","payload","isInitDone","reAuthenticate","logoutCounter","isLogoutPending","logout","loginRedirect","useBackup","backup","backupId","save","toDiff","diffData","withUpdates","restore","currentInstance"],"mappings":"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","x_google_ignoreList":[0,1,10,11,17,18,20,28,29,36,56]}